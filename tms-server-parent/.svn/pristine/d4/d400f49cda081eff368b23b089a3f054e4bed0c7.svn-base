package com.taomee.tms.storm.lib;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.taomee.tms.mgr.api.LogMgrService;
import com.taomee.tms.mgr.entity.CustomQueryParams;
import com.taomee.tms.mgr.entity.StidSStidRefLog;

/**
 * Author looper. Company TaoMee.Inc, ShangHai. Date 2017/7/5.
 * 1.模拟从dubbo服务那边获取StidSstidGidRef的映射信息. 2.根据上面的映射信息在内存当中初始化Map的映射信息.
 * 3.转换每条日志的信息.
 */
public class OldCustomLogRefNewLog implements Serializable {
	private static Logger LOG = LoggerFactory.getLogger(OldCustomLogRefNewLog.class);
	private static final long serialVersionUID = 1L;
	private Map<String, String> stidSStidRefLogMaps = new HashMap<>();//保存stidsstid到logid的映射消息,map存储的容量1073741824
	private Map<String,Long> validstidSStidRefLogMaps = new HashMap<String,Long>();
	private String noDealWithMessage = new String();//对于logid>0的日志，已经在同一个并行的topology作业当中处理过。
	private LogMgrService logMgrService;//如果不希望该属性被序列化,添加transient关键字修饰

	public static void main(String[] args) {
		/**
		 * 构造映射信息,这部分最后信息需要调用dubbo那边服务，获取整个自定义日志到logid的映射信息.
		 */
		/*List<StidSStidRefLog> stidRefLogsLists = new ArrayList<>();
		//StidSStidRefLog stidSStidRefLog = new StidSStidRefLog("主线剧情", "完成步骤1",
				632, 10);
		StidSStidRefLog stidSStidRefLog2 = new StidSStidRefLog("主线剧情", "完成步骤2",
				632, 11);
		stidRefLogsLists.add(stidSStidRefLog);
		stidRefLogsLists.add(stidSStidRefLog2);*/
	}

	/**
	 * 初始化2Map信息
	 * 
	 * @param stidRefLogsLists
	 * @param gpzsGidRefServerLists
	 */
	public void init2MapsInfo(List<StidSStidRefLog> stidRefLogsLists,LogMgrService logMgrService) {
		stidSStidRefLogMaps.clear();
		// gpzsGidRefServerMaps.clear();

		for (StidSStidRefLog stidSStidRefLog : stidRefLogsLists) {
			stidSStidRefLogMaps.put(
					stidSStidRefLog.getStid() + "|"+ stidSStidRefLog.getSstid() + "|"+ stidSStidRefLog.getGameId() + "|" +stidSStidRefLog.getOp(),
					String.valueOf(stidSStidRefLog.getLogId()));
			LOG.info("{},{} put into StidSStidRefLog map,map size:{}",stidSStidRefLog.getStid() + "|"+ stidSStidRefLog.getSstid() + "|"+ stidSStidRefLog.getGameId() + "|" +stidSStidRefLog.getOp(),String.valueOf(stidSStidRefLog.getLogId()),stidSStidRefLogMaps.size());
		}

		this.logMgrService = logMgrService;

	}

	@SuppressWarnings("finally")
	public String old2new(String oldLog) {
		Map<String, String> maps = new HashMap<>();
		maps.clear();
		String[] oldLog_array = oldLog.split("\\s+");
		for (String split_log : oldLog_array) {
			String strKv = split_log;
			String[] kv = strKv.split("=", -1);
			if (kv.length < 2) {
				System.out.println("kv键值对有误:" + strKv + "," + oldLog + "!");
				continue;
			}
			maps.put(kv[0], kv[1]);
		}
		
		if (maps.containsKey("_logid_")) {
			if (Integer.valueOf(maps.get("_logid_")) > 0) {
				return noDealWithMessage;
			}
			return oldLog;
		}

		else if (maps.containsKey("_stid_") && maps.containsKey("_sstid_")
				&& maps.containsKey("_gid_")) {

			String stid_sstid_gid_op = maps.get("_stid_") + "|"+ maps.get("_sstid_") + "|" + maps.get("_gid_") + "|" + maps.get("_op_");

			if(stidSStidRefLogMaps.containsKey(stid_sstid_gid_op)){
				if(validstidSStidRefLogMaps.containsKey(stid_sstid_gid_op)){
					if(System.currentTimeMillis()-validstidSStidRefLogMaps.get(stid_sstid_gid_op)>43200000){
						validstidSStidRefLogMaps.put(stid_sstid_gid_op, System.currentTimeMillis());
						logMgrService.getCustomLogInfo(maps.get("_stid_"), maps.get("_sstid_"),Integer.valueOf(maps.get("_gid_")),maps.get("_op_"), true, 86400*4);
						LOG.info("{} already in valid sssopgid list for over 43200 seconds,update redis expire seconds.",stid_sstid_gid_op);
					}else{
						LOG.debug("{} already in valid sssopgid list less than 43200 seconds,not to update redis expire seconds",stid_sstid_gid_op);
					}
				}else{
					validstidSStidRefLogMaps.put(stid_sstid_gid_op, System.currentTimeMillis());
					logMgrService.getCustomLogInfo(maps.get("_stid_"), maps.get("_sstid_"),Integer.valueOf(maps.get("_gid_")),maps.get("_op_"), true, 86400*4);
					LOG.info("{} put into valid sssopgid list,updating redis expire seconds.",stid_sstid_gid_op);
				}
				maps.remove("_stid_");
				maps.remove("_sstid_");
				maps.remove("_op_");
				maps.put("_logid_", stidSStidRefLogMaps.get(stid_sstid_gid_op));
				LOG.debug("log \"{}\" get sss2logid map from memory,kv is <{},{}>",oldLog,stid_sstid_gid_op,stidSStidRefLogMaps.get(stid_sstid_gid_op));
			}else{
				int index = 0;
				LOG.info("{} not found in StidSstidRefLogMaps,getting information by logMgrService with retry No.{}...",stid_sstid_gid_op,index);
				while (true) {

					if(maps.get("_op_") == null){
						maps.put("_op_","null");
					}
					CustomQueryParams customQueryParams = new CustomQueryParams(maps.get("_stid_"),maps.get("_sstid_"),Integer.valueOf(maps.get("_gid_")),maps.get("_op_"));
					
					Integer logid = -1;// 后台返回的gid不可能 为负数的

					try {
						logid = logMgrService.getCustomLogInfo(customQueryParams,true,86400*3+60*60*12);//先去redis查找，如果没有则去db进行查找，还没有则插入记录并写redis再返回
						if (logid > 0) {
							LOG.info("{} get logID {} by logMgrService",stid_sstid_gid_op,logid);
							maps.put("_logid_", String.valueOf(logid));
							maps.remove("_stid_");
							maps.remove("_sstid_");
							maps.remove("_op_");
							stidSStidRefLogMaps.put(stid_sstid_gid_op,String.valueOf(logid));
							LOG.info("{},{} put into stidSStidRefLogMaps,map size:{}",stid_sstid_gid_op,logid,stidSStidRefLogMaps.size());
							validstidSStidRefLogMaps.put(stid_sstid_gid_op, System.currentTimeMillis());
							LOG.info("{} put into valid sssopgid list,update redis expire seconds.",stid_sstid_gid_op);
//							LOG.debug("log \"{}\" get sss2logid map from dubbo logMgrService,kv is <{},{}>",oldLog,stid_sstid_gid_op,logid);
							break;
						}else{
							LOG.warn("get logID {} by logMgrService with key {}",logid,stid_sstid_gid_op);
						}
					} catch (Exception e) {
						e.printStackTrace();
						LOG.warn("Exception happened during inserting customQueryParams "+ customQueryParams.toString());
						
						index++;
						if(index >= 6)
						{
							LOG.error("Failed to insert {} by logMgrService.Max retries {} exceeded.",customQueryParams.toString(),index);//丢掉该实时的数据,后面可考虑在这边加策略
							return noDealWithMessage;
						}
						continue;
					}
				}

			}

		}

		StringBuilder builder = new StringBuilder();
		for (Map.Entry<String, String> entry : maps.entrySet()) {

			builder.append(entry.getKey() + "=" + entry.getValue());
			builder.append("\t");
		}
		
		return builder.toString();
	}

	/**
	 * 第二种自定义日志打散方式，去掉之前的找不到日志需要往后台发送插入，现在没找到的数据(这种情况应该不存在的,
	 * 因为之前几步MR已经拿到了截止当天为止全量的合法自定义映射数据)直接丢掉。
	 * 
	 * @param oldLog
	 * @return
	 */
	public String oldCustomLogToNewCustomLog(String oldLog) {
		Map<String, String> maps = new HashMap<>();
		maps.clear();
		String[] oldLog_array = oldLog.split("\t");
		for (String split_log : oldLog_array) {
			String strKv = split_log;
			String[] kv = strKv.split("=", -1);
			if (kv.length < 2) {
				System.out.println("kv键值对有误:" + strKv + ", " + oldLog);
				continue;
			}
			maps.put(kv[0], kv[1]);
		}

		if (maps.containsKey("_logid_")) {

			if (Integer.valueOf(maps.get("_logid_")) > 0) {

				return noDealWithMessage;
			}
			return oldLog;
		}

		else if (maps.containsKey("_stid_") && maps.containsKey("_sstid_")
				&& maps.containsKey("_gid_")) {

			/**
			 * 查找映射表当中是否存在stid+sstid+gid+op,如果存在需要替换成新的logid,同时把stid、sstid以及op字段去掉。
			 */
			String stid_sstid_gid_op = maps.get("_stid_") + "|"
					+ maps.get("_sstid_") + "|" + maps.get("_gid_") +"|"+maps.get("_op_");

			if (stidSStidRefLogMaps.containsKey(stid_sstid_gid_op)) {
				/**
				 * 如果存在，去掉原先日志当中的stid、sstid、op,减少现在日志的数量,因为现在很多自定义日志都是中文的，很占空间
				 */
				maps.remove("_stid_");
				maps.remove("_sstid_");
				maps.remove("_op_");
				maps.put("_logid_", stidSStidRefLogMaps.get(stid_sstid_gid_op));

			} else {
				LOG.error("error custom log =>" + oldLog);
				return noDealWithMessage;
			}

		}

		StringBuilder builder = new StringBuilder();
		for (Map.Entry<String, String> entry : maps.entrySet()) {

			builder.append(entry.getKey() + "=" + entry.getValue());
			builder.append("\t");
		}
		return builder.toString();
	}

	/**
	 * 对于新的自定义数据映射，需要往dubbo后台插入这条新的日志映射信息
	 * 
	 * @param oldLog
	 * @return
	 */
	public void insertNewLog(CustomQueryParams customQueryParams) {
		/**
		 * 之前一步的reducer已经判断了最后的日志分割后的数组长度为4
		 */
		/*
		 * String[] customLogParams = newCustomLog.split("\t"); String stid =
		 * customLogParams[0]; String sstid = customLogParams[1]; String gid =
		 * customLogParams[2]; String op = customLogParams[3];
		 */

		/**
		 * 拼接成后台的自定义查询参数
		 */
		/*
		 * CustomQueryParams customQueryParams = new CustomQueryParams();
		 * customQueryParams.setStid(stid); customQueryParams.setSstid(sstid);
		 * customQueryParams.setGameId(Integer.valueOf(gid));
		 * customQueryParams.setOp(op);
		 */

		Integer newLogid = -1;
		/**
		 * 后期如果不希望无限插入,可以配置插入index最大尝试次数,避免DB一致被在被插入数据
		 */
		int index = 1;

		while (true) {
			try {

				newLogid = logMgrService.insertCustomLogInfo(customQueryParams);

				LOG.info(customQueryParams.getStid() + ","
						+ customQueryParams.getSstid() + ","
						+ customQueryParams.getGameId() + ":" + "第" + index
						+ "次尝试DB插入...");
				if (newLogid > 0) {
					break;
				} else {
					// 不会出现else这一分支计算的
					index++;
					continue;
				}
			} catch (Exception e) {
				e.printStackTrace();
				index++;
				continue;
			}
		}
	}

	/**
	 * 判断stid、sstid、gid 是否存在
	 * @param customQueryParams
	 * @return
	 */
	public boolean isExistStidSstidGid(CustomQueryParams customQueryParams) {
		String stid_sstid_gid_op = customQueryParams.getStid() + "|"
				+ customQueryParams.getSstid() + "|"
				+ customQueryParams.getGameId() +"|"
				+ customQueryParams.getOp();
		boolean flag = stidSStidRefLogMaps.containsKey(stid_sstid_gid_op);
		if (flag) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * 打印内存的映射关系
	 */
	public void printstidSStidRefLogMapsInfo() {
		for (Map.Entry<String, String> entry : stidSStidRefLogMaps.entrySet()) {
			/*
			 * System.out.println("key:" + entry.getKey() + ",value:" +
			 * entry.getValue());
			 */
			LOG.info("key:" + entry.getKey() + ",value:" + entry.getValue());
		}
	}

}
