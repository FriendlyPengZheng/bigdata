// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: statlogger.proto

#ifndef PROTOBUF_statlogger_2eproto__INCLUDED
#define PROTOBUF_statlogger_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "statlogger.common.pb.h"
// @@protoc_insertion_point(includes)

namespace statlogger {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_statlogger_2eproto();
void protobuf_AssignDesc_statlogger_2eproto();
void protobuf_ShutdownFile_statlogger_2eproto();

class cs_0xF001_veri_pass_t;
class sc_0xF001_veri_pass_t;
class cs_0xF002_reg_role_t;
class sc_0xF002_reg_role_t;
class cs_0xF003_login_online_t;
class sc_0xF003_login_online_t;
class cs_0xF004_logout_t;
class sc_0xF004_logout_t;
class cs_0xF005_online_count_t;
class sc_0xF005_online_count_t;
class cs_0xF006_level_up_t;
class sc_0xF006_level_up_t;
class cs_0xF007_pay_t;
class sc_0xF007_pay_t;
class cs_0xF008_free_golds_t;
class sc_0xF008_free_golds_t;
class cs_0xF009_buy_item_t;
class sc_0xF009_buy_item_t;
class cs_0xF00A_buy_other_t;
class sc_0xF00A_buy_other_t;
class cs_0xF00B_accept_task_t;
class sc_0xF00B_accept_task_t;
class cs_0xF00C_finish_task_t;
class sc_0xF00C_finish_task_t;
class cs_0xF00D_abort_task_t;
class sc_0xF00D_abort_task_t;
class cs_0xF00E_obtain_spirit_t;
class sc_0xF00E_obtain_spirit_t;
class cs_0xF00F_lose_spirit_t;
class sc_0xF00F_lose_spirit_t;
class cs_0xF010_new_trans_t;
class sc_0xF010_new_trans_t;
class cs_0xF100_custom_t;
class sc_0xF100_custom_t;

enum zone_type_t {
  TEL = 1,
  NET = 2,
  ALL = 3
};
bool zone_type_t_IsValid(int value);
const zone_type_t zone_type_t_MIN = TEL;
const zone_type_t zone_type_t_MAX = ALL;
const int zone_type_t_ARRAYSIZE = zone_type_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* zone_type_t_descriptor();
inline const ::std::string& zone_type_t_Name(zone_type_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    zone_type_t_descriptor(), value);
}
inline bool zone_type_t_Parse(
    const ::std::string& name, zone_type_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<zone_type_t>(
    zone_type_t_descriptor(), name, value);
}
enum unit_t {
  YUAN = 1,
  JIAO = 2,
  FEN = 3
};
bool unit_t_IsValid(int value);
const unit_t unit_t_MIN = YUAN;
const unit_t unit_t_MAX = FEN;
const int unit_t_ARRAYSIZE = unit_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* unit_t_descriptor();
inline const ::std::string& unit_t_Name(unit_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    unit_t_descriptor(), value);
}
inline bool unit_t_Parse(
    const ::std::string& name, unit_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<unit_t>(
    unit_t_descriptor(), name, value);
}
enum currency_t {
  MIBI = 1,
  RMB = 2
};
bool currency_t_IsValid(int value);
const currency_t currency_t_MIN = MIBI;
const currency_t currency_t_MAX = RMB;
const int currency_t_ARRAYSIZE = currency_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* currency_t_descriptor();
inline const ::std::string& currency_t_Name(currency_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    currency_t_descriptor(), value);
}
inline bool currency_t_Parse(
    const ::std::string& name, currency_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<currency_t>(
    currency_t_descriptor(), name, value);
}
enum pay_reason_t {
  PAY_BUY = 1,
  PAY_VIP = 2
};
bool pay_reason_t_IsValid(int value);
const pay_reason_t pay_reason_t_MIN = PAY_BUY;
const pay_reason_t pay_reason_t_MAX = PAY_VIP;
const int pay_reason_t_ARRAYSIZE = pay_reason_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* pay_reason_t_descriptor();
inline const ::std::string& pay_reason_t_Name(pay_reason_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    pay_reason_t_descriptor(), value);
}
inline bool pay_reason_t_Parse(
    const ::std::string& name, pay_reason_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<pay_reason_t>(
    pay_reason_t_descriptor(), name, value);
}
enum task_type_t {
  BEGIN = 1,
  MAIN = 2,
  AUX = 3,
  ETC = 4
};
bool task_type_t_IsValid(int value);
const task_type_t task_type_t_MIN = BEGIN;
const task_type_t task_type_t_MAX = ETC;
const int task_type_t_ARRAYSIZE = task_type_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* task_type_t_descriptor();
inline const ::std::string& task_type_t_Name(task_type_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    task_type_t_descriptor(), value);
}
inline bool task_type_t_Parse(
    const ::std::string& name, task_type_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<task_type_t>(
    task_type_t_descriptor(), name, value);
}
enum reg_trans_step_t {
  fGetRegSucc = 1,
  fLoadRegSucc = 2,
  fSendLoginReq = 3,
  bGetLoginReq = 4,
  bSendLoginReq = 5,
  bGetLoginSucc = 6,
  fGetLoginSucc = 7,
  fLoadLoginSucc = 8,
  fClickStartBtn = 9,
  bGetNewroleReq = 10,
  bSendNewroleSucc = 11,
  fStartSrvlistReq = 12,
  bStartGetSrvlist = 13,
  bGetSrvlistSucc = 14,
  fGetSrvlistSucc = 15,
  fSendOnlineReq = 16,
  fSend1001Req = 17,
  bSendOnlineSucc = 18,
  fOnlineSucc = 19,
  fLoadInfoSucc = 20,
  fInterGameSucc = 21
};
bool reg_trans_step_t_IsValid(int value);
const reg_trans_step_t reg_trans_step_t_MIN = fGetRegSucc;
const reg_trans_step_t reg_trans_step_t_MAX = fInterGameSucc;
const int reg_trans_step_t_ARRAYSIZE = reg_trans_step_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* reg_trans_step_t_descriptor();
inline const ::std::string& reg_trans_step_t_Name(reg_trans_step_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    reg_trans_step_t_descriptor(), value);
}
inline bool reg_trans_step_t_Parse(
    const ::std::string& name, reg_trans_step_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<reg_trans_step_t>(
    reg_trans_step_t_descriptor(), name, value);
}
enum op_type_t {
  SUM = 1,
  MAX = 2,
  SET = 3
};
bool op_type_t_IsValid(int value);
const op_type_t op_type_t_MIN = SUM;
const op_type_t op_type_t_MAX = SET;
const int op_type_t_ARRAYSIZE = op_type_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* op_type_t_descriptor();
inline const ::std::string& op_type_t_Name(op_type_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    op_type_t_descriptor(), value);
}
inline bool op_type_t_Parse(
    const ::std::string& name, op_type_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<op_type_t>(
    op_type_t_descriptor(), name, value);
}
// ===================================================================

class cs_0xF001_veri_pass_t : public ::google::protobuf::Message {
 public:
  cs_0xF001_veri_pass_t();
  virtual ~cs_0xF001_veri_pass_t();

  cs_0xF001_veri_pass_t(const cs_0xF001_veri_pass_t& from);

  inline cs_0xF001_veri_pass_t& operator=(const cs_0xF001_veri_pass_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF001_veri_pass_t& default_instance();

  void Swap(cs_0xF001_veri_pass_t* other);

  // implements Message ----------------------------------------------

  cs_0xF001_veri_pass_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF001_veri_pass_t& from);
  void MergeFrom(const cs_0xF001_veri_pass_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // optional string client_ip = 3;
  inline bool has_client_ip() const;
  inline void clear_client_ip();
  static const int kClientIpFieldNumber = 3;
  inline const ::std::string& client_ip() const;
  inline void set_client_ip(const ::std::string& value);
  inline void set_client_ip(const char* value);
  inline void set_client_ip(const char* value, size_t size);
  inline ::std::string* mutable_client_ip();
  inline ::std::string* release_client_ip();
  inline void set_allocated_client_ip(::std::string* client_ip);

  // optional string ads_id = 4;
  inline bool has_ads_id() const;
  inline void clear_ads_id();
  static const int kAdsIdFieldNumber = 4;
  inline const ::std::string& ads_id() const;
  inline void set_ads_id(const ::std::string& value);
  inline void set_ads_id(const char* value);
  inline void set_ads_id(const char* value, size_t size);
  inline ::std::string* mutable_ads_id();
  inline ::std::string* release_ads_id();
  inline void set_allocated_ads_id(::std::string* ads_id);

  // optional string browse = 5;
  inline bool has_browse() const;
  inline void clear_browse();
  static const int kBrowseFieldNumber = 5;
  inline const ::std::string& browse() const;
  inline void set_browse(const ::std::string& value);
  inline void set_browse(const char* value);
  inline void set_browse(const char* value, size_t size);
  inline ::std::string* mutable_browse();
  inline ::std::string* release_browse();
  inline void set_allocated_browse(::std::string* browse);

  // optional string device = 6;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 6;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // optional string os = 7;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 7;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string resolution = 8;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 8;
  inline const ::std::string& resolution() const;
  inline void set_resolution(const ::std::string& value);
  inline void set_resolution(const char* value);
  inline void set_resolution(const char* value, size_t size);
  inline ::std::string* mutable_resolution();
  inline ::std::string* release_resolution();
  inline void set_allocated_resolution(::std::string* resolution);

  // optional string network = 9;
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 9;
  inline const ::std::string& network() const;
  inline void set_network(const ::std::string& value);
  inline void set_network(const char* value);
  inline void set_network(const char* value, size_t size);
  inline ::std::string* mutable_network();
  inline ::std::string* release_network();
  inline void set_allocated_network(::std::string* network);

  // optional string isp = 10;
  inline bool has_isp() const;
  inline void clear_isp();
  static const int kIspFieldNumber = 10;
  inline const ::std::string& isp() const;
  inline void set_isp(const ::std::string& value);
  inline void set_isp(const char* value);
  inline void set_isp(const char* value, size_t size);
  inline ::std::string* mutable_isp();
  inline ::std::string* release_isp();
  inline void set_allocated_isp(::std::string* isp);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF001_veri_pass_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_client_ip();
  inline void clear_has_client_ip();
  inline void set_has_ads_id();
  inline void clear_has_ads_id();
  inline void set_has_browse();
  inline void clear_has_browse();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_isp();
  inline void clear_has_isp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  ::std::string* client_ip_;
  ::std::string* ads_id_;
  ::std::string* browse_;
  ::std::string* device_;
  ::std::string* os_;
  ::std::string* resolution_;
  ::std::string* network_;
  ::std::string* isp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF001_veri_pass_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF001_veri_pass_t : public ::google::protobuf::Message {
 public:
  sc_0xF001_veri_pass_t();
  virtual ~sc_0xF001_veri_pass_t();

  sc_0xF001_veri_pass_t(const sc_0xF001_veri_pass_t& from);

  inline sc_0xF001_veri_pass_t& operator=(const sc_0xF001_veri_pass_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF001_veri_pass_t& default_instance();

  void Swap(sc_0xF001_veri_pass_t* other);

  // implements Message ----------------------------------------------

  sc_0xF001_veri_pass_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF001_veri_pass_t& from);
  void MergeFrom(const sc_0xF001_veri_pass_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF001_veri_pass_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF001_veri_pass_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF002_reg_role_t : public ::google::protobuf::Message {
 public:
  cs_0xF002_reg_role_t();
  virtual ~cs_0xF002_reg_role_t();

  cs_0xF002_reg_role_t(const cs_0xF002_reg_role_t& from);

  inline cs_0xF002_reg_role_t& operator=(const cs_0xF002_reg_role_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF002_reg_role_t& default_instance();

  void Swap(cs_0xF002_reg_role_t* other);

  // implements Message ----------------------------------------------

  cs_0xF002_reg_role_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF002_reg_role_t& from);
  void MergeFrom(const cs_0xF002_reg_role_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // optional string race = 3;
  inline bool has_race() const;
  inline void clear_race();
  static const int kRaceFieldNumber = 3;
  inline const ::std::string& race() const;
  inline void set_race(const ::std::string& value);
  inline void set_race(const char* value);
  inline void set_race(const char* value, size_t size);
  inline ::std::string* mutable_race();
  inline ::std::string* release_race();
  inline void set_allocated_race(::std::string* race);

  // optional string client_ip = 4;
  inline bool has_client_ip() const;
  inline void clear_client_ip();
  static const int kClientIpFieldNumber = 4;
  inline const ::std::string& client_ip() const;
  inline void set_client_ip(const ::std::string& value);
  inline void set_client_ip(const char* value);
  inline void set_client_ip(const char* value, size_t size);
  inline ::std::string* mutable_client_ip();
  inline ::std::string* release_client_ip();
  inline void set_allocated_client_ip(::std::string* client_ip);

  // optional string ads_id = 5;
  inline bool has_ads_id() const;
  inline void clear_ads_id();
  static const int kAdsIdFieldNumber = 5;
  inline const ::std::string& ads_id() const;
  inline void set_ads_id(const ::std::string& value);
  inline void set_ads_id(const char* value);
  inline void set_ads_id(const char* value, size_t size);
  inline ::std::string* mutable_ads_id();
  inline ::std::string* release_ads_id();
  inline void set_allocated_ads_id(::std::string* ads_id);

  // optional string browse = 6;
  inline bool has_browse() const;
  inline void clear_browse();
  static const int kBrowseFieldNumber = 6;
  inline const ::std::string& browse() const;
  inline void set_browse(const ::std::string& value);
  inline void set_browse(const char* value);
  inline void set_browse(const char* value, size_t size);
  inline ::std::string* mutable_browse();
  inline ::std::string* release_browse();
  inline void set_allocated_browse(::std::string* browse);

  // optional string device = 7;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 7;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // optional string os = 8;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 8;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string resolution = 9;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 9;
  inline const ::std::string& resolution() const;
  inline void set_resolution(const ::std::string& value);
  inline void set_resolution(const char* value);
  inline void set_resolution(const char* value, size_t size);
  inline ::std::string* mutable_resolution();
  inline ::std::string* release_resolution();
  inline void set_allocated_resolution(::std::string* resolution);

  // optional string network = 10;
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 10;
  inline const ::std::string& network() const;
  inline void set_network(const ::std::string& value);
  inline void set_network(const char* value);
  inline void set_network(const char* value, size_t size);
  inline ::std::string* mutable_network();
  inline ::std::string* release_network();
  inline void set_allocated_network(::std::string* network);

  // optional string isp = 11;
  inline bool has_isp() const;
  inline void clear_isp();
  static const int kIspFieldNumber = 11;
  inline const ::std::string& isp() const;
  inline void set_isp(const ::std::string& value);
  inline void set_isp(const char* value);
  inline void set_isp(const char* value, size_t size);
  inline ::std::string* mutable_isp();
  inline ::std::string* release_isp();
  inline void set_allocated_isp(::std::string* isp);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF002_reg_role_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_race();
  inline void clear_has_race();
  inline void set_has_client_ip();
  inline void clear_has_client_ip();
  inline void set_has_ads_id();
  inline void clear_has_ads_id();
  inline void set_has_browse();
  inline void clear_has_browse();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_isp();
  inline void clear_has_isp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  ::std::string* race_;
  ::std::string* client_ip_;
  ::std::string* ads_id_;
  ::std::string* browse_;
  ::std::string* device_;
  ::std::string* os_;
  ::std::string* resolution_;
  ::std::string* network_;
  ::std::string* isp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF002_reg_role_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF002_reg_role_t : public ::google::protobuf::Message {
 public:
  sc_0xF002_reg_role_t();
  virtual ~sc_0xF002_reg_role_t();

  sc_0xF002_reg_role_t(const sc_0xF002_reg_role_t& from);

  inline sc_0xF002_reg_role_t& operator=(const sc_0xF002_reg_role_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF002_reg_role_t& default_instance();

  void Swap(sc_0xF002_reg_role_t* other);

  // implements Message ----------------------------------------------

  sc_0xF002_reg_role_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF002_reg_role_t& from);
  void MergeFrom(const sc_0xF002_reg_role_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF002_reg_role_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF002_reg_role_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF003_login_online_t : public ::google::protobuf::Message {
 public:
  cs_0xF003_login_online_t();
  virtual ~cs_0xF003_login_online_t();

  cs_0xF003_login_online_t(const cs_0xF003_login_online_t& from);

  inline cs_0xF003_login_online_t& operator=(const cs_0xF003_login_online_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF003_login_online_t& default_instance();

  void Swap(cs_0xF003_login_online_t* other);

  // implements Message ----------------------------------------------

  cs_0xF003_login_online_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF003_login_online_t& from);
  void MergeFrom(const cs_0xF003_login_online_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // optional string race = 3;
  inline bool has_race() const;
  inline void clear_race();
  static const int kRaceFieldNumber = 3;
  inline const ::std::string& race() const;
  inline void set_race(const ::std::string& value);
  inline void set_race(const char* value);
  inline void set_race(const char* value, size_t size);
  inline ::std::string* mutable_race();
  inline ::std::string* release_race();
  inline void set_allocated_race(::std::string* race);

  // optional bool isvip = 4;
  inline bool has_isvip() const;
  inline void clear_isvip();
  static const int kIsvipFieldNumber = 4;
  inline bool isvip() const;
  inline void set_isvip(bool value);

  // optional uint32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional string client_ip = 6;
  inline bool has_client_ip() const;
  inline void clear_client_ip();
  static const int kClientIpFieldNumber = 6;
  inline const ::std::string& client_ip() const;
  inline void set_client_ip(const ::std::string& value);
  inline void set_client_ip(const char* value);
  inline void set_client_ip(const char* value, size_t size);
  inline ::std::string* mutable_client_ip();
  inline ::std::string* release_client_ip();
  inline void set_allocated_client_ip(::std::string* client_ip);

  // optional string ads_id = 7;
  inline bool has_ads_id() const;
  inline void clear_ads_id();
  static const int kAdsIdFieldNumber = 7;
  inline const ::std::string& ads_id() const;
  inline void set_ads_id(const ::std::string& value);
  inline void set_ads_id(const char* value);
  inline void set_ads_id(const char* value, size_t size);
  inline ::std::string* mutable_ads_id();
  inline ::std::string* release_ads_id();
  inline void set_allocated_ads_id(::std::string* ads_id);

  // optional .statlogger.zone_type_t zone = 8;
  inline bool has_zone() const;
  inline void clear_zone();
  static const int kZoneFieldNumber = 8;
  inline ::statlogger::zone_type_t zone() const;
  inline void set_zone(::statlogger::zone_type_t value);

  // optional string browse = 9;
  inline bool has_browse() const;
  inline void clear_browse();
  static const int kBrowseFieldNumber = 9;
  inline const ::std::string& browse() const;
  inline void set_browse(const ::std::string& value);
  inline void set_browse(const char* value);
  inline void set_browse(const char* value, size_t size);
  inline ::std::string* mutable_browse();
  inline ::std::string* release_browse();
  inline void set_allocated_browse(::std::string* browse);

  // optional string device = 10;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 10;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // optional string os = 11;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 11;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string resolution = 12;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 12;
  inline const ::std::string& resolution() const;
  inline void set_resolution(const ::std::string& value);
  inline void set_resolution(const char* value);
  inline void set_resolution(const char* value, size_t size);
  inline ::std::string* mutable_resolution();
  inline ::std::string* release_resolution();
  inline void set_allocated_resolution(::std::string* resolution);

  // optional string network = 13;
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 13;
  inline const ::std::string& network() const;
  inline void set_network(const ::std::string& value);
  inline void set_network(const char* value);
  inline void set_network(const char* value, size_t size);
  inline ::std::string* mutable_network();
  inline ::std::string* release_network();
  inline void set_allocated_network(::std::string* network);

  // optional string isp = 14;
  inline bool has_isp() const;
  inline void clear_isp();
  static const int kIspFieldNumber = 14;
  inline const ::std::string& isp() const;
  inline void set_isp(const ::std::string& value);
  inline void set_isp(const char* value);
  inline void set_isp(const char* value, size_t size);
  inline ::std::string* mutable_isp();
  inline ::std::string* release_isp();
  inline void set_allocated_isp(::std::string* isp);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF003_login_online_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_race();
  inline void clear_has_race();
  inline void set_has_isvip();
  inline void clear_has_isvip();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_client_ip();
  inline void clear_has_client_ip();
  inline void set_has_ads_id();
  inline void clear_has_ads_id();
  inline void set_has_zone();
  inline void clear_has_zone();
  inline void set_has_browse();
  inline void clear_has_browse();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_isp();
  inline void clear_has_isp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  ::std::string* race_;
  bool isvip_;
  ::google::protobuf::uint32 level_;
  ::std::string* client_ip_;
  ::std::string* ads_id_;
  ::std::string* browse_;
  ::std::string* device_;
  ::std::string* os_;
  ::std::string* resolution_;
  ::std::string* network_;
  ::std::string* isp_;
  int zone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF003_login_online_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF003_login_online_t : public ::google::protobuf::Message {
 public:
  sc_0xF003_login_online_t();
  virtual ~sc_0xF003_login_online_t();

  sc_0xF003_login_online_t(const sc_0xF003_login_online_t& from);

  inline sc_0xF003_login_online_t& operator=(const sc_0xF003_login_online_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF003_login_online_t& default_instance();

  void Swap(sc_0xF003_login_online_t* other);

  // implements Message ----------------------------------------------

  sc_0xF003_login_online_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF003_login_online_t& from);
  void MergeFrom(const sc_0xF003_login_online_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF003_login_online_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF003_login_online_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF004_logout_t : public ::google::protobuf::Message {
 public:
  cs_0xF004_logout_t();
  virtual ~cs_0xF004_logout_t();

  cs_0xF004_logout_t(const cs_0xF004_logout_t& from);

  inline cs_0xF004_logout_t& operator=(const cs_0xF004_logout_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF004_logout_t& default_instance();

  void Swap(cs_0xF004_logout_t* other);

  // implements Message ----------------------------------------------

  cs_0xF004_logout_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF004_logout_t& from);
  void MergeFrom(const cs_0xF004_logout_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // required uint32 oltime = 3;
  inline bool has_oltime() const;
  inline void clear_oltime();
  static const int kOltimeFieldNumber = 3;
  inline ::google::protobuf::uint32 oltime() const;
  inline void set_oltime(::google::protobuf::uint32 value);

  // optional bool isvip = 4;
  inline bool has_isvip() const;
  inline void clear_isvip();
  static const int kIsvipFieldNumber = 4;
  inline bool isvip() const;
  inline void set_isvip(bool value);

  // optional uint32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF004_logout_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_oltime();
  inline void clear_has_oltime();
  inline void set_has_isvip();
  inline void clear_has_isvip();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  ::google::protobuf::uint32 oltime_;
  bool isvip_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF004_logout_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF004_logout_t : public ::google::protobuf::Message {
 public:
  sc_0xF004_logout_t();
  virtual ~sc_0xF004_logout_t();

  sc_0xF004_logout_t(const sc_0xF004_logout_t& from);

  inline sc_0xF004_logout_t& operator=(const sc_0xF004_logout_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF004_logout_t& default_instance();

  void Swap(sc_0xF004_logout_t* other);

  // implements Message ----------------------------------------------

  sc_0xF004_logout_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF004_logout_t& from);
  void MergeFrom(const sc_0xF004_logout_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF004_logout_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF004_logout_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF005_online_count_t : public ::google::protobuf::Message {
 public:
  cs_0xF005_online_count_t();
  virtual ~cs_0xF005_online_count_t();

  cs_0xF005_online_count_t(const cs_0xF005_online_count_t& from);

  inline cs_0xF005_online_count_t& operator=(const cs_0xF005_online_count_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF005_online_count_t& default_instance();

  void Swap(cs_0xF005_online_count_t* other);

  // implements Message ----------------------------------------------

  cs_0xF005_online_count_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF005_online_count_t& from);
  void MergeFrom(const cs_0xF005_online_count_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required uint32 olcnt = 2;
  inline bool has_olcnt() const;
  inline void clear_olcnt();
  static const int kOlcntFieldNumber = 2;
  inline ::google::protobuf::uint32 olcnt() const;
  inline void set_olcnt(::google::protobuf::uint32 value);

  // optional .statlogger.zone_type_t zone = 3 [default = ALL];
  inline bool has_zone() const;
  inline void clear_zone();
  static const int kZoneFieldNumber = 3;
  inline ::statlogger::zone_type_t zone() const;
  inline void set_zone(::statlogger::zone_type_t value);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF005_online_count_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_olcnt();
  inline void clear_has_olcnt();
  inline void set_has_zone();
  inline void clear_has_zone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::google::protobuf::uint32 olcnt_;
  int zone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF005_online_count_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF005_online_count_t : public ::google::protobuf::Message {
 public:
  sc_0xF005_online_count_t();
  virtual ~sc_0xF005_online_count_t();

  sc_0xF005_online_count_t(const sc_0xF005_online_count_t& from);

  inline sc_0xF005_online_count_t& operator=(const sc_0xF005_online_count_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF005_online_count_t& default_instance();

  void Swap(sc_0xF005_online_count_t* other);

  // implements Message ----------------------------------------------

  sc_0xF005_online_count_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF005_online_count_t& from);
  void MergeFrom(const sc_0xF005_online_count_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF005_online_count_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF005_online_count_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF006_level_up_t : public ::google::protobuf::Message {
 public:
  cs_0xF006_level_up_t();
  virtual ~cs_0xF006_level_up_t();

  cs_0xF006_level_up_t(const cs_0xF006_level_up_t& from);

  inline cs_0xF006_level_up_t& operator=(const cs_0xF006_level_up_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF006_level_up_t& default_instance();

  void Swap(cs_0xF006_level_up_t* other);

  // implements Message ----------------------------------------------

  cs_0xF006_level_up_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF006_level_up_t& from);
  void MergeFrom(const cs_0xF006_level_up_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // required uint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional string race = 4;
  inline bool has_race() const;
  inline void clear_race();
  static const int kRaceFieldNumber = 4;
  inline const ::std::string& race() const;
  inline void set_race(const ::std::string& value);
  inline void set_race(const char* value);
  inline void set_race(const char* value, size_t size);
  inline ::std::string* mutable_race();
  inline ::std::string* release_race();
  inline void set_allocated_race(::std::string* race);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF006_level_up_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_race();
  inline void clear_has_race();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  ::std::string* race_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF006_level_up_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF006_level_up_t : public ::google::protobuf::Message {
 public:
  sc_0xF006_level_up_t();
  virtual ~sc_0xF006_level_up_t();

  sc_0xF006_level_up_t(const sc_0xF006_level_up_t& from);

  inline sc_0xF006_level_up_t& operator=(const sc_0xF006_level_up_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF006_level_up_t& default_instance();

  void Swap(sc_0xF006_level_up_t* other);

  // implements Message ----------------------------------------------

  sc_0xF006_level_up_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF006_level_up_t& from);
  void MergeFrom(const sc_0xF006_level_up_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF006_level_up_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF006_level_up_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF007_pay_t : public ::google::protobuf::Message {
 public:
  cs_0xF007_pay_t();
  virtual ~cs_0xF007_pay_t();

  cs_0xF007_pay_t(const cs_0xF007_pay_t& from);

  inline cs_0xF007_pay_t& operator=(const cs_0xF007_pay_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF007_pay_t& default_instance();

  void Swap(cs_0xF007_pay_t* other);

  // implements Message ----------------------------------------------

  cs_0xF007_pay_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF007_pay_t& from);
  void MergeFrom(const cs_0xF007_pay_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // optional bool isvip = 3;
  inline bool has_isvip() const;
  inline void clear_isvip();
  static const int kIsvipFieldNumber = 3;
  inline bool isvip() const;
  inline void set_isvip(bool value);

  // required uint32 pay_amount = 4;
  inline bool has_pay_amount() const;
  inline void clear_pay_amount();
  static const int kPayAmountFieldNumber = 4;
  inline ::google::protobuf::uint32 pay_amount() const;
  inline void set_pay_amount(::google::protobuf::uint32 value);

  // required .statlogger.unit_t pay_unit = 5 [default = FEN];
  inline bool has_pay_unit() const;
  inline void clear_pay_unit();
  static const int kPayUnitFieldNumber = 5;
  inline ::statlogger::unit_t pay_unit() const;
  inline void set_pay_unit(::statlogger::unit_t value);

  // required .statlogger.currency_t currency_type = 6 [default = MIBI];
  inline bool has_currency_type() const;
  inline void clear_currency_type();
  static const int kCurrencyTypeFieldNumber = 6;
  inline ::statlogger::currency_t currency_type() const;
  inline void set_currency_type(::statlogger::currency_t value);

  // required .statlogger.pay_reason_t pay_reason = 7;
  inline bool has_pay_reason() const;
  inline void clear_pay_reason();
  static const int kPayReasonFieldNumber = 7;
  inline ::statlogger::pay_reason_t pay_reason() const;
  inline void set_pay_reason(::statlogger::pay_reason_t value);

  // required uint32 outcome = 8;
  inline bool has_outcome() const;
  inline void clear_outcome();
  static const int kOutcomeFieldNumber = 8;
  inline ::google::protobuf::uint32 outcome() const;
  inline void set_outcome(::google::protobuf::uint32 value);

  // optional uint32 outcnt = 9 [default = 1];
  inline bool has_outcnt() const;
  inline void clear_outcnt();
  static const int kOutcntFieldNumber = 9;
  inline ::google::protobuf::uint32 outcnt() const;
  inline void set_outcnt(::google::protobuf::uint32 value);

  // required uint32 pay_channel = 10;
  inline bool has_pay_channel() const;
  inline void clear_pay_channel();
  static const int kPayChannelFieldNumber = 10;
  inline ::google::protobuf::uint32 pay_channel() const;
  inline void set_pay_channel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF007_pay_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_isvip();
  inline void clear_has_isvip();
  inline void set_has_pay_amount();
  inline void clear_has_pay_amount();
  inline void set_has_pay_unit();
  inline void clear_has_pay_unit();
  inline void set_has_currency_type();
  inline void clear_has_currency_type();
  inline void set_has_pay_reason();
  inline void clear_has_pay_reason();
  inline void set_has_outcome();
  inline void clear_has_outcome();
  inline void set_has_outcnt();
  inline void clear_has_outcnt();
  inline void set_has_pay_channel();
  inline void clear_has_pay_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  bool isvip_;
  ::google::protobuf::uint32 pay_amount_;
  int pay_unit_;
  int currency_type_;
  int pay_reason_;
  ::google::protobuf::uint32 outcome_;
  ::google::protobuf::uint32 outcnt_;
  ::google::protobuf::uint32 pay_channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF007_pay_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF007_pay_t : public ::google::protobuf::Message {
 public:
  sc_0xF007_pay_t();
  virtual ~sc_0xF007_pay_t();

  sc_0xF007_pay_t(const sc_0xF007_pay_t& from);

  inline sc_0xF007_pay_t& operator=(const sc_0xF007_pay_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF007_pay_t& default_instance();

  void Swap(sc_0xF007_pay_t* other);

  // implements Message ----------------------------------------------

  sc_0xF007_pay_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF007_pay_t& from);
  void MergeFrom(const sc_0xF007_pay_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF007_pay_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF007_pay_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF008_free_golds_t : public ::google::protobuf::Message {
 public:
  cs_0xF008_free_golds_t();
  virtual ~cs_0xF008_free_golds_t();

  cs_0xF008_free_golds_t(const cs_0xF008_free_golds_t& from);

  inline cs_0xF008_free_golds_t& operator=(const cs_0xF008_free_golds_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF008_free_golds_t& default_instance();

  void Swap(cs_0xF008_free_golds_t* other);

  // implements Message ----------------------------------------------

  cs_0xF008_free_golds_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF008_free_golds_t& from);
  void MergeFrom(const cs_0xF008_free_golds_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // required uint32 amt = 3;
  inline bool has_amt() const;
  inline void clear_amt();
  static const int kAmtFieldNumber = 3;
  inline ::google::protobuf::uint32 amt() const;
  inline void set_amt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF008_free_golds_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_amt();
  inline void clear_has_amt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  ::google::protobuf::uint32 amt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF008_free_golds_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF008_free_golds_t : public ::google::protobuf::Message {
 public:
  sc_0xF008_free_golds_t();
  virtual ~sc_0xF008_free_golds_t();

  sc_0xF008_free_golds_t(const sc_0xF008_free_golds_t& from);

  inline sc_0xF008_free_golds_t& operator=(const sc_0xF008_free_golds_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF008_free_golds_t& default_instance();

  void Swap(sc_0xF008_free_golds_t* other);

  // implements Message ----------------------------------------------

  sc_0xF008_free_golds_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF008_free_golds_t& from);
  void MergeFrom(const sc_0xF008_free_golds_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF008_free_golds_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF008_free_golds_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF009_buy_item_t : public ::google::protobuf::Message {
 public:
  cs_0xF009_buy_item_t();
  virtual ~cs_0xF009_buy_item_t();

  cs_0xF009_buy_item_t(const cs_0xF009_buy_item_t& from);

  inline cs_0xF009_buy_item_t& operator=(const cs_0xF009_buy_item_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF009_buy_item_t& default_instance();

  void Swap(cs_0xF009_buy_item_t* other);

  // implements Message ----------------------------------------------

  cs_0xF009_buy_item_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF009_buy_item_t& from);
  void MergeFrom(const cs_0xF009_buy_item_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // optional bool isvip = 3;
  inline bool has_isvip() const;
  inline void clear_isvip();
  static const int kIsvipFieldNumber = 3;
  inline bool isvip() const;
  inline void set_isvip(bool value);

  // optional uint32 lv = 4;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 4;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // required uint32 pay_amt = 5;
  inline bool has_pay_amt() const;
  inline void clear_pay_amt();
  static const int kPayAmtFieldNumber = 5;
  inline ::google::protobuf::uint32 pay_amt() const;
  inline void set_pay_amt(::google::protobuf::uint32 value);

  // required string outcome = 6;
  inline bool has_outcome() const;
  inline void clear_outcome();
  static const int kOutcomeFieldNumber = 6;
  inline const ::std::string& outcome() const;
  inline void set_outcome(const ::std::string& value);
  inline void set_outcome(const char* value);
  inline void set_outcome(const char* value, size_t size);
  inline ::std::string* mutable_outcome();
  inline ::std::string* release_outcome();
  inline void set_allocated_outcome(::std::string* outcome);

  // optional uint32 outcnt = 7 [default = 1];
  inline bool has_outcnt() const;
  inline void clear_outcnt();
  static const int kOutcntFieldNumber = 7;
  inline ::google::protobuf::uint32 outcnt() const;
  inline void set_outcnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF009_buy_item_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_isvip();
  inline void clear_has_isvip();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_pay_amt();
  inline void clear_has_pay_amt();
  inline void set_has_outcome();
  inline void clear_has_outcome();
  inline void set_has_outcnt();
  inline void clear_has_outcnt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  bool isvip_;
  ::google::protobuf::uint32 lv_;
  ::std::string* outcome_;
  ::google::protobuf::uint32 pay_amt_;
  ::google::protobuf::uint32 outcnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF009_buy_item_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF009_buy_item_t : public ::google::protobuf::Message {
 public:
  sc_0xF009_buy_item_t();
  virtual ~sc_0xF009_buy_item_t();

  sc_0xF009_buy_item_t(const sc_0xF009_buy_item_t& from);

  inline sc_0xF009_buy_item_t& operator=(const sc_0xF009_buy_item_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF009_buy_item_t& default_instance();

  void Swap(sc_0xF009_buy_item_t* other);

  // implements Message ----------------------------------------------

  sc_0xF009_buy_item_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF009_buy_item_t& from);
  void MergeFrom(const sc_0xF009_buy_item_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF009_buy_item_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF009_buy_item_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF00A_buy_other_t : public ::google::protobuf::Message {
 public:
  cs_0xF00A_buy_other_t();
  virtual ~cs_0xF00A_buy_other_t();

  cs_0xF00A_buy_other_t(const cs_0xF00A_buy_other_t& from);

  inline cs_0xF00A_buy_other_t& operator=(const cs_0xF00A_buy_other_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF00A_buy_other_t& default_instance();

  void Swap(cs_0xF00A_buy_other_t* other);

  // implements Message ----------------------------------------------

  cs_0xF00A_buy_other_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF00A_buy_other_t& from);
  void MergeFrom(const cs_0xF00A_buy_other_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // optional bool isvip = 3;
  inline bool has_isvip() const;
  inline void clear_isvip();
  static const int kIsvipFieldNumber = 3;
  inline bool isvip() const;
  inline void set_isvip(bool value);

  // optional uint32 lv = 4;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 4;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // required uint32 pay_amt = 5;
  inline bool has_pay_amt() const;
  inline void clear_pay_amt();
  static const int kPayAmtFieldNumber = 5;
  inline ::google::protobuf::uint32 pay_amt() const;
  inline void set_pay_amt(::google::protobuf::uint32 value);

  // required string reason = 6;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 6;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF00A_buy_other_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_isvip();
  inline void clear_has_isvip();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_pay_amt();
  inline void clear_has_pay_amt();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  bool isvip_;
  ::google::protobuf::uint32 lv_;
  ::std::string* reason_;
  ::google::protobuf::uint32 pay_amt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF00A_buy_other_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF00A_buy_other_t : public ::google::protobuf::Message {
 public:
  sc_0xF00A_buy_other_t();
  virtual ~sc_0xF00A_buy_other_t();

  sc_0xF00A_buy_other_t(const sc_0xF00A_buy_other_t& from);

  inline sc_0xF00A_buy_other_t& operator=(const sc_0xF00A_buy_other_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF00A_buy_other_t& default_instance();

  void Swap(sc_0xF00A_buy_other_t* other);

  // implements Message ----------------------------------------------

  sc_0xF00A_buy_other_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF00A_buy_other_t& from);
  void MergeFrom(const sc_0xF00A_buy_other_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF00A_buy_other_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF00A_buy_other_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF00B_accept_task_t : public ::google::protobuf::Message {
 public:
  cs_0xF00B_accept_task_t();
  virtual ~cs_0xF00B_accept_task_t();

  cs_0xF00B_accept_task_t(const cs_0xF00B_accept_task_t& from);

  inline cs_0xF00B_accept_task_t& operator=(const cs_0xF00B_accept_task_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF00B_accept_task_t& default_instance();

  void Swap(cs_0xF00B_accept_task_t* other);

  // implements Message ----------------------------------------------

  cs_0xF00B_accept_task_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF00B_accept_task_t& from);
  void MergeFrom(const cs_0xF00B_accept_task_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // optional uint32 lv = 3;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 3;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // required .statlogger.task_type_t type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::statlogger::task_type_t type() const;
  inline void set_type(::statlogger::task_type_t value);

  // required string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF00B_accept_task_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  ::google::protobuf::uint32 lv_;
  int type_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF00B_accept_task_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF00B_accept_task_t : public ::google::protobuf::Message {
 public:
  sc_0xF00B_accept_task_t();
  virtual ~sc_0xF00B_accept_task_t();

  sc_0xF00B_accept_task_t(const sc_0xF00B_accept_task_t& from);

  inline sc_0xF00B_accept_task_t& operator=(const sc_0xF00B_accept_task_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF00B_accept_task_t& default_instance();

  void Swap(sc_0xF00B_accept_task_t* other);

  // implements Message ----------------------------------------------

  sc_0xF00B_accept_task_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF00B_accept_task_t& from);
  void MergeFrom(const sc_0xF00B_accept_task_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF00B_accept_task_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF00B_accept_task_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF00C_finish_task_t : public ::google::protobuf::Message {
 public:
  cs_0xF00C_finish_task_t();
  virtual ~cs_0xF00C_finish_task_t();

  cs_0xF00C_finish_task_t(const cs_0xF00C_finish_task_t& from);

  inline cs_0xF00C_finish_task_t& operator=(const cs_0xF00C_finish_task_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF00C_finish_task_t& default_instance();

  void Swap(cs_0xF00C_finish_task_t* other);

  // implements Message ----------------------------------------------

  cs_0xF00C_finish_task_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF00C_finish_task_t& from);
  void MergeFrom(const cs_0xF00C_finish_task_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // optional uint32 lv = 3;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 3;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // required .statlogger.task_type_t type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::statlogger::task_type_t type() const;
  inline void set_type(::statlogger::task_type_t value);

  // required string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF00C_finish_task_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  ::google::protobuf::uint32 lv_;
  int type_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF00C_finish_task_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF00C_finish_task_t : public ::google::protobuf::Message {
 public:
  sc_0xF00C_finish_task_t();
  virtual ~sc_0xF00C_finish_task_t();

  sc_0xF00C_finish_task_t(const sc_0xF00C_finish_task_t& from);

  inline sc_0xF00C_finish_task_t& operator=(const sc_0xF00C_finish_task_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF00C_finish_task_t& default_instance();

  void Swap(sc_0xF00C_finish_task_t* other);

  // implements Message ----------------------------------------------

  sc_0xF00C_finish_task_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF00C_finish_task_t& from);
  void MergeFrom(const sc_0xF00C_finish_task_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF00C_finish_task_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF00C_finish_task_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF00D_abort_task_t : public ::google::protobuf::Message {
 public:
  cs_0xF00D_abort_task_t();
  virtual ~cs_0xF00D_abort_task_t();

  cs_0xF00D_abort_task_t(const cs_0xF00D_abort_task_t& from);

  inline cs_0xF00D_abort_task_t& operator=(const cs_0xF00D_abort_task_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF00D_abort_task_t& default_instance();

  void Swap(cs_0xF00D_abort_task_t* other);

  // implements Message ----------------------------------------------

  cs_0xF00D_abort_task_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF00D_abort_task_t& from);
  void MergeFrom(const cs_0xF00D_abort_task_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // optional uint32 lv = 3;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 3;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // required .statlogger.task_type_t type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::statlogger::task_type_t type() const;
  inline void set_type(::statlogger::task_type_t value);

  // required string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF00D_abort_task_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  ::google::protobuf::uint32 lv_;
  int type_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF00D_abort_task_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF00D_abort_task_t : public ::google::protobuf::Message {
 public:
  sc_0xF00D_abort_task_t();
  virtual ~sc_0xF00D_abort_task_t();

  sc_0xF00D_abort_task_t(const sc_0xF00D_abort_task_t& from);

  inline sc_0xF00D_abort_task_t& operator=(const sc_0xF00D_abort_task_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF00D_abort_task_t& default_instance();

  void Swap(sc_0xF00D_abort_task_t* other);

  // implements Message ----------------------------------------------

  sc_0xF00D_abort_task_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF00D_abort_task_t& from);
  void MergeFrom(const sc_0xF00D_abort_task_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF00D_abort_task_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF00D_abort_task_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF00E_obtain_spirit_t : public ::google::protobuf::Message {
 public:
  cs_0xF00E_obtain_spirit_t();
  virtual ~cs_0xF00E_obtain_spirit_t();

  cs_0xF00E_obtain_spirit_t(const cs_0xF00E_obtain_spirit_t& from);

  inline cs_0xF00E_obtain_spirit_t& operator=(const cs_0xF00E_obtain_spirit_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF00E_obtain_spirit_t& default_instance();

  void Swap(cs_0xF00E_obtain_spirit_t* other);

  // implements Message ----------------------------------------------

  cs_0xF00E_obtain_spirit_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF00E_obtain_spirit_t& from);
  void MergeFrom(const cs_0xF00E_obtain_spirit_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // optional uint32 lv = 3;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 3;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // optional bool isvip = 4;
  inline bool has_isvip() const;
  inline void clear_isvip();
  static const int kIsvipFieldNumber = 4;
  inline bool isvip() const;
  inline void set_isvip(bool value);

  // required string spirit = 5;
  inline bool has_spirit() const;
  inline void clear_spirit();
  static const int kSpiritFieldNumber = 5;
  inline const ::std::string& spirit() const;
  inline void set_spirit(const ::std::string& value);
  inline void set_spirit(const char* value);
  inline void set_spirit(const char* value, size_t size);
  inline ::std::string* mutable_spirit();
  inline ::std::string* release_spirit();
  inline void set_allocated_spirit(::std::string* spirit);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF00E_obtain_spirit_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_isvip();
  inline void clear_has_isvip();
  inline void set_has_spirit();
  inline void clear_has_spirit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  ::google::protobuf::uint32 lv_;
  bool isvip_;
  ::std::string* spirit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF00E_obtain_spirit_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF00E_obtain_spirit_t : public ::google::protobuf::Message {
 public:
  sc_0xF00E_obtain_spirit_t();
  virtual ~sc_0xF00E_obtain_spirit_t();

  sc_0xF00E_obtain_spirit_t(const sc_0xF00E_obtain_spirit_t& from);

  inline sc_0xF00E_obtain_spirit_t& operator=(const sc_0xF00E_obtain_spirit_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF00E_obtain_spirit_t& default_instance();

  void Swap(sc_0xF00E_obtain_spirit_t* other);

  // implements Message ----------------------------------------------

  sc_0xF00E_obtain_spirit_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF00E_obtain_spirit_t& from);
  void MergeFrom(const sc_0xF00E_obtain_spirit_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF00E_obtain_spirit_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF00E_obtain_spirit_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF00F_lose_spirit_t : public ::google::protobuf::Message {
 public:
  cs_0xF00F_lose_spirit_t();
  virtual ~cs_0xF00F_lose_spirit_t();

  cs_0xF00F_lose_spirit_t(const cs_0xF00F_lose_spirit_t& from);

  inline cs_0xF00F_lose_spirit_t& operator=(const cs_0xF00F_lose_spirit_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF00F_lose_spirit_t& default_instance();

  void Swap(cs_0xF00F_lose_spirit_t* other);

  // implements Message ----------------------------------------------

  cs_0xF00F_lose_spirit_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF00F_lose_spirit_t& from);
  void MergeFrom(const cs_0xF00F_lose_spirit_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // optional uint32 lv = 3;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 3;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // optional bool isvip = 4;
  inline bool has_isvip() const;
  inline void clear_isvip();
  static const int kIsvipFieldNumber = 4;
  inline bool isvip() const;
  inline void set_isvip(bool value);

  // required string spirit = 5;
  inline bool has_spirit() const;
  inline void clear_spirit();
  static const int kSpiritFieldNumber = 5;
  inline const ::std::string& spirit() const;
  inline void set_spirit(const ::std::string& value);
  inline void set_spirit(const char* value);
  inline void set_spirit(const char* value, size_t size);
  inline ::std::string* mutable_spirit();
  inline ::std::string* release_spirit();
  inline void set_allocated_spirit(::std::string* spirit);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF00F_lose_spirit_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_isvip();
  inline void clear_has_isvip();
  inline void set_has_spirit();
  inline void clear_has_spirit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  ::google::protobuf::uint32 lv_;
  bool isvip_;
  ::std::string* spirit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF00F_lose_spirit_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF00F_lose_spirit_t : public ::google::protobuf::Message {
 public:
  sc_0xF00F_lose_spirit_t();
  virtual ~sc_0xF00F_lose_spirit_t();

  sc_0xF00F_lose_spirit_t(const sc_0xF00F_lose_spirit_t& from);

  inline sc_0xF00F_lose_spirit_t& operator=(const sc_0xF00F_lose_spirit_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF00F_lose_spirit_t& default_instance();

  void Swap(sc_0xF00F_lose_spirit_t* other);

  // implements Message ----------------------------------------------

  sc_0xF00F_lose_spirit_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF00F_lose_spirit_t& from);
  void MergeFrom(const sc_0xF00F_lose_spirit_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF00F_lose_spirit_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF00F_lose_spirit_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF010_new_trans_t : public ::google::protobuf::Message {
 public:
  cs_0xF010_new_trans_t();
  virtual ~cs_0xF010_new_trans_t();

  cs_0xF010_new_trans_t(const cs_0xF010_new_trans_t& from);

  inline cs_0xF010_new_trans_t& operator=(const cs_0xF010_new_trans_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF010_new_trans_t& default_instance();

  void Swap(cs_0xF010_new_trans_t* other);

  // implements Message ----------------------------------------------

  cs_0xF010_new_trans_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF010_new_trans_t& from);
  void MergeFrom(const cs_0xF010_new_trans_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // required .statlogger.reg_trans_step_t step = 3;
  inline bool has_step() const;
  inline void clear_step();
  static const int kStepFieldNumber = 3;
  inline ::statlogger::reg_trans_step_t step() const;
  inline void set_step(::statlogger::reg_trans_step_t value);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF010_new_trans_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_step();
  inline void clear_has_step();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  int step_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF010_new_trans_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF010_new_trans_t : public ::google::protobuf::Message {
 public:
  sc_0xF010_new_trans_t();
  virtual ~sc_0xF010_new_trans_t();

  sc_0xF010_new_trans_t(const sc_0xF010_new_trans_t& from);

  inline sc_0xF010_new_trans_t& operator=(const sc_0xF010_new_trans_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF010_new_trans_t& default_instance();

  void Swap(sc_0xF010_new_trans_t* other);

  // implements Message ----------------------------------------------

  sc_0xF010_new_trans_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF010_new_trans_t& from);
  void MergeFrom(const sc_0xF010_new_trans_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF010_new_trans_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF010_new_trans_t* default_instance_;
};
// -------------------------------------------------------------------

class cs_0xF100_custom_t : public ::google::protobuf::Message {
 public:
  cs_0xF100_custom_t();
  virtual ~cs_0xF100_custom_t();

  cs_0xF100_custom_t(const cs_0xF100_custom_t& from);

  inline cs_0xF100_custom_t& operator=(const cs_0xF100_custom_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_0xF100_custom_t& default_instance();

  void Swap(cs_0xF100_custom_t* other);

  // implements Message ----------------------------------------------

  cs_0xF100_custom_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_0xF100_custom_t& from);
  void MergeFrom(const cs_0xF100_custom_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.game_info_t game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::statloggercommon::game_info_t& game() const;
  inline ::statloggercommon::game_info_t* mutable_game();
  inline ::statloggercommon::game_info_t* release_game();
  inline void set_allocated_game(::statloggercommon::game_info_t* game);

  // required .statloggercommon.user_id_t uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::statloggercommon::user_id_t& uid() const;
  inline ::statloggercommon::user_id_t* mutable_uid();
  inline ::statloggercommon::user_id_t* release_uid();
  inline void set_allocated_uid(::statloggercommon::user_id_t* uid);

  // required string stid = 3;
  inline bool has_stid() const;
  inline void clear_stid();
  static const int kStidFieldNumber = 3;
  inline const ::std::string& stid() const;
  inline void set_stid(const ::std::string& value);
  inline void set_stid(const char* value);
  inline void set_stid(const char* value, size_t size);
  inline ::std::string* mutable_stid();
  inline ::std::string* release_stid();
  inline void set_allocated_stid(::std::string* stid);

  // required string sstid = 4;
  inline bool has_sstid() const;
  inline void clear_sstid();
  static const int kSstidFieldNumber = 4;
  inline const ::std::string& sstid() const;
  inline void set_sstid(const ::std::string& value);
  inline void set_sstid(const char* value);
  inline void set_sstid(const char* value, size_t size);
  inline ::std::string* mutable_sstid();
  inline ::std::string* release_sstid();
  inline void set_allocated_sstid(::std::string* sstid);

  // optional string item = 5;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 5;
  inline const ::std::string& item() const;
  inline void set_item(const ::std::string& value);
  inline void set_item(const char* value);
  inline void set_item(const char* value, size_t size);
  inline ::std::string* mutable_item();
  inline ::std::string* release_item();
  inline void set_allocated_item(::std::string* item);

  // optional .statlogger.op_type_t op = 6;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 6;
  inline ::statlogger::op_type_t op() const;
  inline void set_op(::statlogger::op_type_t value);

  // optional string key = 7 [default = "key"];
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 7;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional double value = 8;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 8;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:statlogger.cs_0xF100_custom_t)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_stid();
  inline void clear_has_stid();
  inline void set_has_sstid();
  inline void clear_has_sstid();
  inline void set_has_item();
  inline void clear_has_item();
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::game_info_t* game_;
  ::statloggercommon::user_id_t* uid_;
  ::std::string* stid_;
  ::std::string* sstid_;
  ::std::string* item_;
  ::std::string* key_;
  static ::std::string* _default_key_;
  double value_;
  int op_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static cs_0xF100_custom_t* default_instance_;
};
// -------------------------------------------------------------------

class sc_0xF100_custom_t : public ::google::protobuf::Message {
 public:
  sc_0xF100_custom_t();
  virtual ~sc_0xF100_custom_t();

  sc_0xF100_custom_t(const sc_0xF100_custom_t& from);

  inline sc_0xF100_custom_t& operator=(const sc_0xF100_custom_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_0xF100_custom_t& default_instance();

  void Swap(sc_0xF100_custom_t* other);

  // implements Message ----------------------------------------------

  sc_0xF100_custom_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_0xF100_custom_t& from);
  void MergeFrom(const sc_0xF100_custom_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .statloggercommon.return_t ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline const ::statloggercommon::return_t& ret() const;
  inline ::statloggercommon::return_t* mutable_ret();
  inline ::statloggercommon::return_t* release_ret();
  inline void set_allocated_ret(::statloggercommon::return_t* ret);

  // @@protoc_insertion_point(class_scope:statlogger.sc_0xF100_custom_t)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::statloggercommon::return_t* ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_statlogger_2eproto();
  friend void protobuf_AssignDesc_statlogger_2eproto();
  friend void protobuf_ShutdownFile_statlogger_2eproto();

  void InitAsDefaultInstance();
  static sc_0xF100_custom_t* default_instance_;
};
// ===================================================================


// ===================================================================

// cs_0xF001_veri_pass_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF001_veri_pass_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF001_veri_pass_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF001_veri_pass_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF001_veri_pass_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF001_veri_pass_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF001_veri_pass_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF001_veri_pass_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF001_veri_pass_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF001_veri_pass_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF001_veri_pass_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF001_veri_pass_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF001_veri_pass_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF001_veri_pass_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF001_veri_pass_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF001_veri_pass_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF001_veri_pass_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// optional string client_ip = 3;
inline bool cs_0xF001_veri_pass_t::has_client_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF001_veri_pass_t::set_has_client_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF001_veri_pass_t::clear_has_client_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF001_veri_pass_t::clear_client_ip() {
  if (client_ip_ != &::google::protobuf::internal::kEmptyString) {
    client_ip_->clear();
  }
  clear_has_client_ip();
}
inline const ::std::string& cs_0xF001_veri_pass_t::client_ip() const {
  return *client_ip_;
}
inline void cs_0xF001_veri_pass_t::set_client_ip(const ::std::string& value) {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  client_ip_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_client_ip(const char* value) {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  client_ip_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_client_ip(const char* value, size_t size) {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  client_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF001_veri_pass_t::mutable_client_ip() {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  return client_ip_;
}
inline ::std::string* cs_0xF001_veri_pass_t::release_client_ip() {
  clear_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_ip_;
    client_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF001_veri_pass_t::set_allocated_client_ip(::std::string* client_ip) {
  if (client_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete client_ip_;
  }
  if (client_ip) {
    set_has_client_ip();
    client_ip_ = client_ip;
  } else {
    clear_has_client_ip();
    client_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ads_id = 4;
inline bool cs_0xF001_veri_pass_t::has_ads_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cs_0xF001_veri_pass_t::set_has_ads_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cs_0xF001_veri_pass_t::clear_has_ads_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cs_0xF001_veri_pass_t::clear_ads_id() {
  if (ads_id_ != &::google::protobuf::internal::kEmptyString) {
    ads_id_->clear();
  }
  clear_has_ads_id();
}
inline const ::std::string& cs_0xF001_veri_pass_t::ads_id() const {
  return *ads_id_;
}
inline void cs_0xF001_veri_pass_t::set_ads_id(const ::std::string& value) {
  set_has_ads_id();
  if (ads_id_ == &::google::protobuf::internal::kEmptyString) {
    ads_id_ = new ::std::string;
  }
  ads_id_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_ads_id(const char* value) {
  set_has_ads_id();
  if (ads_id_ == &::google::protobuf::internal::kEmptyString) {
    ads_id_ = new ::std::string;
  }
  ads_id_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_ads_id(const char* value, size_t size) {
  set_has_ads_id();
  if (ads_id_ == &::google::protobuf::internal::kEmptyString) {
    ads_id_ = new ::std::string;
  }
  ads_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF001_veri_pass_t::mutable_ads_id() {
  set_has_ads_id();
  if (ads_id_ == &::google::protobuf::internal::kEmptyString) {
    ads_id_ = new ::std::string;
  }
  return ads_id_;
}
inline ::std::string* cs_0xF001_veri_pass_t::release_ads_id() {
  clear_has_ads_id();
  if (ads_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ads_id_;
    ads_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF001_veri_pass_t::set_allocated_ads_id(::std::string* ads_id) {
  if (ads_id_ != &::google::protobuf::internal::kEmptyString) {
    delete ads_id_;
  }
  if (ads_id) {
    set_has_ads_id();
    ads_id_ = ads_id;
  } else {
    clear_has_ads_id();
    ads_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string browse = 5;
inline bool cs_0xF001_veri_pass_t::has_browse() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cs_0xF001_veri_pass_t::set_has_browse() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cs_0xF001_veri_pass_t::clear_has_browse() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cs_0xF001_veri_pass_t::clear_browse() {
  if (browse_ != &::google::protobuf::internal::kEmptyString) {
    browse_->clear();
  }
  clear_has_browse();
}
inline const ::std::string& cs_0xF001_veri_pass_t::browse() const {
  return *browse_;
}
inline void cs_0xF001_veri_pass_t::set_browse(const ::std::string& value) {
  set_has_browse();
  if (browse_ == &::google::protobuf::internal::kEmptyString) {
    browse_ = new ::std::string;
  }
  browse_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_browse(const char* value) {
  set_has_browse();
  if (browse_ == &::google::protobuf::internal::kEmptyString) {
    browse_ = new ::std::string;
  }
  browse_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_browse(const char* value, size_t size) {
  set_has_browse();
  if (browse_ == &::google::protobuf::internal::kEmptyString) {
    browse_ = new ::std::string;
  }
  browse_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF001_veri_pass_t::mutable_browse() {
  set_has_browse();
  if (browse_ == &::google::protobuf::internal::kEmptyString) {
    browse_ = new ::std::string;
  }
  return browse_;
}
inline ::std::string* cs_0xF001_veri_pass_t::release_browse() {
  clear_has_browse();
  if (browse_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = browse_;
    browse_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF001_veri_pass_t::set_allocated_browse(::std::string* browse) {
  if (browse_ != &::google::protobuf::internal::kEmptyString) {
    delete browse_;
  }
  if (browse) {
    set_has_browse();
    browse_ = browse;
  } else {
    clear_has_browse();
    browse_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device = 6;
inline bool cs_0xF001_veri_pass_t::has_device() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void cs_0xF001_veri_pass_t::set_has_device() {
  _has_bits_[0] |= 0x00000020u;
}
inline void cs_0xF001_veri_pass_t::clear_has_device() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void cs_0xF001_veri_pass_t::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& cs_0xF001_veri_pass_t::device() const {
  return *device_;
}
inline void cs_0xF001_veri_pass_t::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF001_veri_pass_t::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* cs_0xF001_veri_pass_t::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF001_veri_pass_t::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string os = 7;
inline bool cs_0xF001_veri_pass_t::has_os() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void cs_0xF001_veri_pass_t::set_has_os() {
  _has_bits_[0] |= 0x00000040u;
}
inline void cs_0xF001_veri_pass_t::clear_has_os() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void cs_0xF001_veri_pass_t::clear_os() {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& cs_0xF001_veri_pass_t::os() const {
  return *os_;
}
inline void cs_0xF001_veri_pass_t::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF001_veri_pass_t::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  return os_;
}
inline ::std::string* cs_0xF001_veri_pass_t::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF001_veri_pass_t::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string resolution = 8;
inline bool cs_0xF001_veri_pass_t::has_resolution() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void cs_0xF001_veri_pass_t::set_has_resolution() {
  _has_bits_[0] |= 0x00000080u;
}
inline void cs_0xF001_veri_pass_t::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void cs_0xF001_veri_pass_t::clear_resolution() {
  if (resolution_ != &::google::protobuf::internal::kEmptyString) {
    resolution_->clear();
  }
  clear_has_resolution();
}
inline const ::std::string& cs_0xF001_veri_pass_t::resolution() const {
  return *resolution_;
}
inline void cs_0xF001_veri_pass_t::set_resolution(const ::std::string& value) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_resolution(const char* value) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_resolution(const char* value, size_t size) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF001_veri_pass_t::mutable_resolution() {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  return resolution_;
}
inline ::std::string* cs_0xF001_veri_pass_t::release_resolution() {
  clear_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resolution_;
    resolution_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF001_veri_pass_t::set_allocated_resolution(::std::string* resolution) {
  if (resolution_ != &::google::protobuf::internal::kEmptyString) {
    delete resolution_;
  }
  if (resolution) {
    set_has_resolution();
    resolution_ = resolution;
  } else {
    clear_has_resolution();
    resolution_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string network = 9;
inline bool cs_0xF001_veri_pass_t::has_network() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void cs_0xF001_veri_pass_t::set_has_network() {
  _has_bits_[0] |= 0x00000100u;
}
inline void cs_0xF001_veri_pass_t::clear_has_network() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void cs_0xF001_veri_pass_t::clear_network() {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    network_->clear();
  }
  clear_has_network();
}
inline const ::std::string& cs_0xF001_veri_pass_t::network() const {
  return *network_;
}
inline void cs_0xF001_veri_pass_t::set_network(const ::std::string& value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_network(const char* value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_network(const char* value, size_t size) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF001_veri_pass_t::mutable_network() {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  return network_;
}
inline ::std::string* cs_0xF001_veri_pass_t::release_network() {
  clear_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_;
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF001_veri_pass_t::set_allocated_network(::std::string* network) {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    delete network_;
  }
  if (network) {
    set_has_network();
    network_ = network;
  } else {
    clear_has_network();
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string isp = 10;
inline bool cs_0xF001_veri_pass_t::has_isp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void cs_0xF001_veri_pass_t::set_has_isp() {
  _has_bits_[0] |= 0x00000200u;
}
inline void cs_0xF001_veri_pass_t::clear_has_isp() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void cs_0xF001_veri_pass_t::clear_isp() {
  if (isp_ != &::google::protobuf::internal::kEmptyString) {
    isp_->clear();
  }
  clear_has_isp();
}
inline const ::std::string& cs_0xF001_veri_pass_t::isp() const {
  return *isp_;
}
inline void cs_0xF001_veri_pass_t::set_isp(const ::std::string& value) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_isp(const char* value) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(value);
}
inline void cs_0xF001_veri_pass_t::set_isp(const char* value, size_t size) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF001_veri_pass_t::mutable_isp() {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  return isp_;
}
inline ::std::string* cs_0xF001_veri_pass_t::release_isp() {
  clear_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = isp_;
    isp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF001_veri_pass_t::set_allocated_isp(::std::string* isp) {
  if (isp_ != &::google::protobuf::internal::kEmptyString) {
    delete isp_;
  }
  if (isp) {
    set_has_isp();
    isp_ = isp;
  } else {
    clear_has_isp();
    isp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// sc_0xF001_veri_pass_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF001_veri_pass_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF001_veri_pass_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF001_veri_pass_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF001_veri_pass_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF001_veri_pass_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF001_veri_pass_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF001_veri_pass_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF001_veri_pass_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF002_reg_role_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF002_reg_role_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF002_reg_role_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF002_reg_role_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF002_reg_role_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF002_reg_role_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF002_reg_role_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF002_reg_role_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF002_reg_role_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF002_reg_role_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF002_reg_role_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF002_reg_role_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF002_reg_role_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF002_reg_role_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF002_reg_role_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF002_reg_role_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF002_reg_role_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// optional string race = 3;
inline bool cs_0xF002_reg_role_t::has_race() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF002_reg_role_t::set_has_race() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF002_reg_role_t::clear_has_race() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF002_reg_role_t::clear_race() {
  if (race_ != &::google::protobuf::internal::kEmptyString) {
    race_->clear();
  }
  clear_has_race();
}
inline const ::std::string& cs_0xF002_reg_role_t::race() const {
  return *race_;
}
inline void cs_0xF002_reg_role_t::set_race(const ::std::string& value) {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  race_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_race(const char* value) {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  race_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_race(const char* value, size_t size) {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  race_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF002_reg_role_t::mutable_race() {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  return race_;
}
inline ::std::string* cs_0xF002_reg_role_t::release_race() {
  clear_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = race_;
    race_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF002_reg_role_t::set_allocated_race(::std::string* race) {
  if (race_ != &::google::protobuf::internal::kEmptyString) {
    delete race_;
  }
  if (race) {
    set_has_race();
    race_ = race;
  } else {
    clear_has_race();
    race_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string client_ip = 4;
inline bool cs_0xF002_reg_role_t::has_client_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cs_0xF002_reg_role_t::set_has_client_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cs_0xF002_reg_role_t::clear_has_client_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cs_0xF002_reg_role_t::clear_client_ip() {
  if (client_ip_ != &::google::protobuf::internal::kEmptyString) {
    client_ip_->clear();
  }
  clear_has_client_ip();
}
inline const ::std::string& cs_0xF002_reg_role_t::client_ip() const {
  return *client_ip_;
}
inline void cs_0xF002_reg_role_t::set_client_ip(const ::std::string& value) {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  client_ip_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_client_ip(const char* value) {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  client_ip_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_client_ip(const char* value, size_t size) {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  client_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF002_reg_role_t::mutable_client_ip() {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  return client_ip_;
}
inline ::std::string* cs_0xF002_reg_role_t::release_client_ip() {
  clear_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_ip_;
    client_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF002_reg_role_t::set_allocated_client_ip(::std::string* client_ip) {
  if (client_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete client_ip_;
  }
  if (client_ip) {
    set_has_client_ip();
    client_ip_ = client_ip;
  } else {
    clear_has_client_ip();
    client_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ads_id = 5;
inline bool cs_0xF002_reg_role_t::has_ads_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cs_0xF002_reg_role_t::set_has_ads_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cs_0xF002_reg_role_t::clear_has_ads_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cs_0xF002_reg_role_t::clear_ads_id() {
  if (ads_id_ != &::google::protobuf::internal::kEmptyString) {
    ads_id_->clear();
  }
  clear_has_ads_id();
}
inline const ::std::string& cs_0xF002_reg_role_t::ads_id() const {
  return *ads_id_;
}
inline void cs_0xF002_reg_role_t::set_ads_id(const ::std::string& value) {
  set_has_ads_id();
  if (ads_id_ == &::google::protobuf::internal::kEmptyString) {
    ads_id_ = new ::std::string;
  }
  ads_id_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_ads_id(const char* value) {
  set_has_ads_id();
  if (ads_id_ == &::google::protobuf::internal::kEmptyString) {
    ads_id_ = new ::std::string;
  }
  ads_id_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_ads_id(const char* value, size_t size) {
  set_has_ads_id();
  if (ads_id_ == &::google::protobuf::internal::kEmptyString) {
    ads_id_ = new ::std::string;
  }
  ads_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF002_reg_role_t::mutable_ads_id() {
  set_has_ads_id();
  if (ads_id_ == &::google::protobuf::internal::kEmptyString) {
    ads_id_ = new ::std::string;
  }
  return ads_id_;
}
inline ::std::string* cs_0xF002_reg_role_t::release_ads_id() {
  clear_has_ads_id();
  if (ads_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ads_id_;
    ads_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF002_reg_role_t::set_allocated_ads_id(::std::string* ads_id) {
  if (ads_id_ != &::google::protobuf::internal::kEmptyString) {
    delete ads_id_;
  }
  if (ads_id) {
    set_has_ads_id();
    ads_id_ = ads_id;
  } else {
    clear_has_ads_id();
    ads_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string browse = 6;
inline bool cs_0xF002_reg_role_t::has_browse() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void cs_0xF002_reg_role_t::set_has_browse() {
  _has_bits_[0] |= 0x00000020u;
}
inline void cs_0xF002_reg_role_t::clear_has_browse() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void cs_0xF002_reg_role_t::clear_browse() {
  if (browse_ != &::google::protobuf::internal::kEmptyString) {
    browse_->clear();
  }
  clear_has_browse();
}
inline const ::std::string& cs_0xF002_reg_role_t::browse() const {
  return *browse_;
}
inline void cs_0xF002_reg_role_t::set_browse(const ::std::string& value) {
  set_has_browse();
  if (browse_ == &::google::protobuf::internal::kEmptyString) {
    browse_ = new ::std::string;
  }
  browse_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_browse(const char* value) {
  set_has_browse();
  if (browse_ == &::google::protobuf::internal::kEmptyString) {
    browse_ = new ::std::string;
  }
  browse_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_browse(const char* value, size_t size) {
  set_has_browse();
  if (browse_ == &::google::protobuf::internal::kEmptyString) {
    browse_ = new ::std::string;
  }
  browse_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF002_reg_role_t::mutable_browse() {
  set_has_browse();
  if (browse_ == &::google::protobuf::internal::kEmptyString) {
    browse_ = new ::std::string;
  }
  return browse_;
}
inline ::std::string* cs_0xF002_reg_role_t::release_browse() {
  clear_has_browse();
  if (browse_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = browse_;
    browse_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF002_reg_role_t::set_allocated_browse(::std::string* browse) {
  if (browse_ != &::google::protobuf::internal::kEmptyString) {
    delete browse_;
  }
  if (browse) {
    set_has_browse();
    browse_ = browse;
  } else {
    clear_has_browse();
    browse_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device = 7;
inline bool cs_0xF002_reg_role_t::has_device() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void cs_0xF002_reg_role_t::set_has_device() {
  _has_bits_[0] |= 0x00000040u;
}
inline void cs_0xF002_reg_role_t::clear_has_device() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void cs_0xF002_reg_role_t::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& cs_0xF002_reg_role_t::device() const {
  return *device_;
}
inline void cs_0xF002_reg_role_t::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF002_reg_role_t::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* cs_0xF002_reg_role_t::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF002_reg_role_t::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string os = 8;
inline bool cs_0xF002_reg_role_t::has_os() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void cs_0xF002_reg_role_t::set_has_os() {
  _has_bits_[0] |= 0x00000080u;
}
inline void cs_0xF002_reg_role_t::clear_has_os() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void cs_0xF002_reg_role_t::clear_os() {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& cs_0xF002_reg_role_t::os() const {
  return *os_;
}
inline void cs_0xF002_reg_role_t::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF002_reg_role_t::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  return os_;
}
inline ::std::string* cs_0xF002_reg_role_t::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF002_reg_role_t::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string resolution = 9;
inline bool cs_0xF002_reg_role_t::has_resolution() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void cs_0xF002_reg_role_t::set_has_resolution() {
  _has_bits_[0] |= 0x00000100u;
}
inline void cs_0xF002_reg_role_t::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void cs_0xF002_reg_role_t::clear_resolution() {
  if (resolution_ != &::google::protobuf::internal::kEmptyString) {
    resolution_->clear();
  }
  clear_has_resolution();
}
inline const ::std::string& cs_0xF002_reg_role_t::resolution() const {
  return *resolution_;
}
inline void cs_0xF002_reg_role_t::set_resolution(const ::std::string& value) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_resolution(const char* value) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_resolution(const char* value, size_t size) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF002_reg_role_t::mutable_resolution() {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  return resolution_;
}
inline ::std::string* cs_0xF002_reg_role_t::release_resolution() {
  clear_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resolution_;
    resolution_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF002_reg_role_t::set_allocated_resolution(::std::string* resolution) {
  if (resolution_ != &::google::protobuf::internal::kEmptyString) {
    delete resolution_;
  }
  if (resolution) {
    set_has_resolution();
    resolution_ = resolution;
  } else {
    clear_has_resolution();
    resolution_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string network = 10;
inline bool cs_0xF002_reg_role_t::has_network() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void cs_0xF002_reg_role_t::set_has_network() {
  _has_bits_[0] |= 0x00000200u;
}
inline void cs_0xF002_reg_role_t::clear_has_network() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void cs_0xF002_reg_role_t::clear_network() {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    network_->clear();
  }
  clear_has_network();
}
inline const ::std::string& cs_0xF002_reg_role_t::network() const {
  return *network_;
}
inline void cs_0xF002_reg_role_t::set_network(const ::std::string& value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_network(const char* value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_network(const char* value, size_t size) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF002_reg_role_t::mutable_network() {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  return network_;
}
inline ::std::string* cs_0xF002_reg_role_t::release_network() {
  clear_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_;
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF002_reg_role_t::set_allocated_network(::std::string* network) {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    delete network_;
  }
  if (network) {
    set_has_network();
    network_ = network;
  } else {
    clear_has_network();
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string isp = 11;
inline bool cs_0xF002_reg_role_t::has_isp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void cs_0xF002_reg_role_t::set_has_isp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void cs_0xF002_reg_role_t::clear_has_isp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void cs_0xF002_reg_role_t::clear_isp() {
  if (isp_ != &::google::protobuf::internal::kEmptyString) {
    isp_->clear();
  }
  clear_has_isp();
}
inline const ::std::string& cs_0xF002_reg_role_t::isp() const {
  return *isp_;
}
inline void cs_0xF002_reg_role_t::set_isp(const ::std::string& value) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_isp(const char* value) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(value);
}
inline void cs_0xF002_reg_role_t::set_isp(const char* value, size_t size) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF002_reg_role_t::mutable_isp() {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  return isp_;
}
inline ::std::string* cs_0xF002_reg_role_t::release_isp() {
  clear_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = isp_;
    isp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF002_reg_role_t::set_allocated_isp(::std::string* isp) {
  if (isp_ != &::google::protobuf::internal::kEmptyString) {
    delete isp_;
  }
  if (isp) {
    set_has_isp();
    isp_ = isp;
  } else {
    clear_has_isp();
    isp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// sc_0xF002_reg_role_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF002_reg_role_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF002_reg_role_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF002_reg_role_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF002_reg_role_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF002_reg_role_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF002_reg_role_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF002_reg_role_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF002_reg_role_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF003_login_online_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF003_login_online_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF003_login_online_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF003_login_online_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF003_login_online_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF003_login_online_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF003_login_online_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF003_login_online_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF003_login_online_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF003_login_online_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF003_login_online_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF003_login_online_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF003_login_online_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF003_login_online_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF003_login_online_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF003_login_online_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF003_login_online_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// optional string race = 3;
inline bool cs_0xF003_login_online_t::has_race() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF003_login_online_t::set_has_race() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF003_login_online_t::clear_has_race() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF003_login_online_t::clear_race() {
  if (race_ != &::google::protobuf::internal::kEmptyString) {
    race_->clear();
  }
  clear_has_race();
}
inline const ::std::string& cs_0xF003_login_online_t::race() const {
  return *race_;
}
inline void cs_0xF003_login_online_t::set_race(const ::std::string& value) {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  race_->assign(value);
}
inline void cs_0xF003_login_online_t::set_race(const char* value) {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  race_->assign(value);
}
inline void cs_0xF003_login_online_t::set_race(const char* value, size_t size) {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  race_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF003_login_online_t::mutable_race() {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  return race_;
}
inline ::std::string* cs_0xF003_login_online_t::release_race() {
  clear_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = race_;
    race_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF003_login_online_t::set_allocated_race(::std::string* race) {
  if (race_ != &::google::protobuf::internal::kEmptyString) {
    delete race_;
  }
  if (race) {
    set_has_race();
    race_ = race;
  } else {
    clear_has_race();
    race_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isvip = 4;
inline bool cs_0xF003_login_online_t::has_isvip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cs_0xF003_login_online_t::set_has_isvip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cs_0xF003_login_online_t::clear_has_isvip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cs_0xF003_login_online_t::clear_isvip() {
  isvip_ = false;
  clear_has_isvip();
}
inline bool cs_0xF003_login_online_t::isvip() const {
  return isvip_;
}
inline void cs_0xF003_login_online_t::set_isvip(bool value) {
  set_has_isvip();
  isvip_ = value;
}

// optional uint32 level = 5;
inline bool cs_0xF003_login_online_t::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cs_0xF003_login_online_t::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cs_0xF003_login_online_t::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cs_0xF003_login_online_t::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 cs_0xF003_login_online_t::level() const {
  return level_;
}
inline void cs_0xF003_login_online_t::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional string client_ip = 6;
inline bool cs_0xF003_login_online_t::has_client_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void cs_0xF003_login_online_t::set_has_client_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void cs_0xF003_login_online_t::clear_has_client_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void cs_0xF003_login_online_t::clear_client_ip() {
  if (client_ip_ != &::google::protobuf::internal::kEmptyString) {
    client_ip_->clear();
  }
  clear_has_client_ip();
}
inline const ::std::string& cs_0xF003_login_online_t::client_ip() const {
  return *client_ip_;
}
inline void cs_0xF003_login_online_t::set_client_ip(const ::std::string& value) {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  client_ip_->assign(value);
}
inline void cs_0xF003_login_online_t::set_client_ip(const char* value) {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  client_ip_->assign(value);
}
inline void cs_0xF003_login_online_t::set_client_ip(const char* value, size_t size) {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  client_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF003_login_online_t::mutable_client_ip() {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  return client_ip_;
}
inline ::std::string* cs_0xF003_login_online_t::release_client_ip() {
  clear_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_ip_;
    client_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF003_login_online_t::set_allocated_client_ip(::std::string* client_ip) {
  if (client_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete client_ip_;
  }
  if (client_ip) {
    set_has_client_ip();
    client_ip_ = client_ip;
  } else {
    clear_has_client_ip();
    client_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ads_id = 7;
inline bool cs_0xF003_login_online_t::has_ads_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void cs_0xF003_login_online_t::set_has_ads_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void cs_0xF003_login_online_t::clear_has_ads_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void cs_0xF003_login_online_t::clear_ads_id() {
  if (ads_id_ != &::google::protobuf::internal::kEmptyString) {
    ads_id_->clear();
  }
  clear_has_ads_id();
}
inline const ::std::string& cs_0xF003_login_online_t::ads_id() const {
  return *ads_id_;
}
inline void cs_0xF003_login_online_t::set_ads_id(const ::std::string& value) {
  set_has_ads_id();
  if (ads_id_ == &::google::protobuf::internal::kEmptyString) {
    ads_id_ = new ::std::string;
  }
  ads_id_->assign(value);
}
inline void cs_0xF003_login_online_t::set_ads_id(const char* value) {
  set_has_ads_id();
  if (ads_id_ == &::google::protobuf::internal::kEmptyString) {
    ads_id_ = new ::std::string;
  }
  ads_id_->assign(value);
}
inline void cs_0xF003_login_online_t::set_ads_id(const char* value, size_t size) {
  set_has_ads_id();
  if (ads_id_ == &::google::protobuf::internal::kEmptyString) {
    ads_id_ = new ::std::string;
  }
  ads_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF003_login_online_t::mutable_ads_id() {
  set_has_ads_id();
  if (ads_id_ == &::google::protobuf::internal::kEmptyString) {
    ads_id_ = new ::std::string;
  }
  return ads_id_;
}
inline ::std::string* cs_0xF003_login_online_t::release_ads_id() {
  clear_has_ads_id();
  if (ads_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ads_id_;
    ads_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF003_login_online_t::set_allocated_ads_id(::std::string* ads_id) {
  if (ads_id_ != &::google::protobuf::internal::kEmptyString) {
    delete ads_id_;
  }
  if (ads_id) {
    set_has_ads_id();
    ads_id_ = ads_id;
  } else {
    clear_has_ads_id();
    ads_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .statlogger.zone_type_t zone = 8;
inline bool cs_0xF003_login_online_t::has_zone() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void cs_0xF003_login_online_t::set_has_zone() {
  _has_bits_[0] |= 0x00000080u;
}
inline void cs_0xF003_login_online_t::clear_has_zone() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void cs_0xF003_login_online_t::clear_zone() {
  zone_ = 1;
  clear_has_zone();
}
inline ::statlogger::zone_type_t cs_0xF003_login_online_t::zone() const {
  return static_cast< ::statlogger::zone_type_t >(zone_);
}
inline void cs_0xF003_login_online_t::set_zone(::statlogger::zone_type_t value) {
  assert(::statlogger::zone_type_t_IsValid(value));
  set_has_zone();
  zone_ = value;
}

// optional string browse = 9;
inline bool cs_0xF003_login_online_t::has_browse() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void cs_0xF003_login_online_t::set_has_browse() {
  _has_bits_[0] |= 0x00000100u;
}
inline void cs_0xF003_login_online_t::clear_has_browse() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void cs_0xF003_login_online_t::clear_browse() {
  if (browse_ != &::google::protobuf::internal::kEmptyString) {
    browse_->clear();
  }
  clear_has_browse();
}
inline const ::std::string& cs_0xF003_login_online_t::browse() const {
  return *browse_;
}
inline void cs_0xF003_login_online_t::set_browse(const ::std::string& value) {
  set_has_browse();
  if (browse_ == &::google::protobuf::internal::kEmptyString) {
    browse_ = new ::std::string;
  }
  browse_->assign(value);
}
inline void cs_0xF003_login_online_t::set_browse(const char* value) {
  set_has_browse();
  if (browse_ == &::google::protobuf::internal::kEmptyString) {
    browse_ = new ::std::string;
  }
  browse_->assign(value);
}
inline void cs_0xF003_login_online_t::set_browse(const char* value, size_t size) {
  set_has_browse();
  if (browse_ == &::google::protobuf::internal::kEmptyString) {
    browse_ = new ::std::string;
  }
  browse_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF003_login_online_t::mutable_browse() {
  set_has_browse();
  if (browse_ == &::google::protobuf::internal::kEmptyString) {
    browse_ = new ::std::string;
  }
  return browse_;
}
inline ::std::string* cs_0xF003_login_online_t::release_browse() {
  clear_has_browse();
  if (browse_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = browse_;
    browse_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF003_login_online_t::set_allocated_browse(::std::string* browse) {
  if (browse_ != &::google::protobuf::internal::kEmptyString) {
    delete browse_;
  }
  if (browse) {
    set_has_browse();
    browse_ = browse;
  } else {
    clear_has_browse();
    browse_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device = 10;
inline bool cs_0xF003_login_online_t::has_device() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void cs_0xF003_login_online_t::set_has_device() {
  _has_bits_[0] |= 0x00000200u;
}
inline void cs_0xF003_login_online_t::clear_has_device() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void cs_0xF003_login_online_t::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& cs_0xF003_login_online_t::device() const {
  return *device_;
}
inline void cs_0xF003_login_online_t::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void cs_0xF003_login_online_t::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void cs_0xF003_login_online_t::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF003_login_online_t::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* cs_0xF003_login_online_t::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF003_login_online_t::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string os = 11;
inline bool cs_0xF003_login_online_t::has_os() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void cs_0xF003_login_online_t::set_has_os() {
  _has_bits_[0] |= 0x00000400u;
}
inline void cs_0xF003_login_online_t::clear_has_os() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void cs_0xF003_login_online_t::clear_os() {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& cs_0xF003_login_online_t::os() const {
  return *os_;
}
inline void cs_0xF003_login_online_t::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void cs_0xF003_login_online_t::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void cs_0xF003_login_online_t::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF003_login_online_t::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  return os_;
}
inline ::std::string* cs_0xF003_login_online_t::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF003_login_online_t::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string resolution = 12;
inline bool cs_0xF003_login_online_t::has_resolution() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void cs_0xF003_login_online_t::set_has_resolution() {
  _has_bits_[0] |= 0x00000800u;
}
inline void cs_0xF003_login_online_t::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void cs_0xF003_login_online_t::clear_resolution() {
  if (resolution_ != &::google::protobuf::internal::kEmptyString) {
    resolution_->clear();
  }
  clear_has_resolution();
}
inline const ::std::string& cs_0xF003_login_online_t::resolution() const {
  return *resolution_;
}
inline void cs_0xF003_login_online_t::set_resolution(const ::std::string& value) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(value);
}
inline void cs_0xF003_login_online_t::set_resolution(const char* value) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(value);
}
inline void cs_0xF003_login_online_t::set_resolution(const char* value, size_t size) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF003_login_online_t::mutable_resolution() {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  return resolution_;
}
inline ::std::string* cs_0xF003_login_online_t::release_resolution() {
  clear_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resolution_;
    resolution_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF003_login_online_t::set_allocated_resolution(::std::string* resolution) {
  if (resolution_ != &::google::protobuf::internal::kEmptyString) {
    delete resolution_;
  }
  if (resolution) {
    set_has_resolution();
    resolution_ = resolution;
  } else {
    clear_has_resolution();
    resolution_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string network = 13;
inline bool cs_0xF003_login_online_t::has_network() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void cs_0xF003_login_online_t::set_has_network() {
  _has_bits_[0] |= 0x00001000u;
}
inline void cs_0xF003_login_online_t::clear_has_network() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void cs_0xF003_login_online_t::clear_network() {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    network_->clear();
  }
  clear_has_network();
}
inline const ::std::string& cs_0xF003_login_online_t::network() const {
  return *network_;
}
inline void cs_0xF003_login_online_t::set_network(const ::std::string& value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void cs_0xF003_login_online_t::set_network(const char* value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void cs_0xF003_login_online_t::set_network(const char* value, size_t size) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF003_login_online_t::mutable_network() {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  return network_;
}
inline ::std::string* cs_0xF003_login_online_t::release_network() {
  clear_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_;
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF003_login_online_t::set_allocated_network(::std::string* network) {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    delete network_;
  }
  if (network) {
    set_has_network();
    network_ = network;
  } else {
    clear_has_network();
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string isp = 14;
inline bool cs_0xF003_login_online_t::has_isp() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void cs_0xF003_login_online_t::set_has_isp() {
  _has_bits_[0] |= 0x00002000u;
}
inline void cs_0xF003_login_online_t::clear_has_isp() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void cs_0xF003_login_online_t::clear_isp() {
  if (isp_ != &::google::protobuf::internal::kEmptyString) {
    isp_->clear();
  }
  clear_has_isp();
}
inline const ::std::string& cs_0xF003_login_online_t::isp() const {
  return *isp_;
}
inline void cs_0xF003_login_online_t::set_isp(const ::std::string& value) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(value);
}
inline void cs_0xF003_login_online_t::set_isp(const char* value) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(value);
}
inline void cs_0xF003_login_online_t::set_isp(const char* value, size_t size) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF003_login_online_t::mutable_isp() {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  return isp_;
}
inline ::std::string* cs_0xF003_login_online_t::release_isp() {
  clear_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = isp_;
    isp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF003_login_online_t::set_allocated_isp(::std::string* isp) {
  if (isp_ != &::google::protobuf::internal::kEmptyString) {
    delete isp_;
  }
  if (isp) {
    set_has_isp();
    isp_ = isp;
  } else {
    clear_has_isp();
    isp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// sc_0xF003_login_online_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF003_login_online_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF003_login_online_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF003_login_online_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF003_login_online_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF003_login_online_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF003_login_online_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF003_login_online_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF003_login_online_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF004_logout_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF004_logout_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF004_logout_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF004_logout_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF004_logout_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF004_logout_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF004_logout_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF004_logout_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF004_logout_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF004_logout_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF004_logout_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF004_logout_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF004_logout_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF004_logout_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF004_logout_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF004_logout_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF004_logout_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// required uint32 oltime = 3;
inline bool cs_0xF004_logout_t::has_oltime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF004_logout_t::set_has_oltime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF004_logout_t::clear_has_oltime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF004_logout_t::clear_oltime() {
  oltime_ = 0u;
  clear_has_oltime();
}
inline ::google::protobuf::uint32 cs_0xF004_logout_t::oltime() const {
  return oltime_;
}
inline void cs_0xF004_logout_t::set_oltime(::google::protobuf::uint32 value) {
  set_has_oltime();
  oltime_ = value;
}

// optional bool isvip = 4;
inline bool cs_0xF004_logout_t::has_isvip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cs_0xF004_logout_t::set_has_isvip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cs_0xF004_logout_t::clear_has_isvip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cs_0xF004_logout_t::clear_isvip() {
  isvip_ = false;
  clear_has_isvip();
}
inline bool cs_0xF004_logout_t::isvip() const {
  return isvip_;
}
inline void cs_0xF004_logout_t::set_isvip(bool value) {
  set_has_isvip();
  isvip_ = value;
}

// optional uint32 level = 5;
inline bool cs_0xF004_logout_t::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cs_0xF004_logout_t::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cs_0xF004_logout_t::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cs_0xF004_logout_t::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 cs_0xF004_logout_t::level() const {
  return level_;
}
inline void cs_0xF004_logout_t::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// sc_0xF004_logout_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF004_logout_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF004_logout_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF004_logout_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF004_logout_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF004_logout_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF004_logout_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF004_logout_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF004_logout_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF005_online_count_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF005_online_count_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF005_online_count_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF005_online_count_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF005_online_count_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF005_online_count_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF005_online_count_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF005_online_count_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF005_online_count_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required uint32 olcnt = 2;
inline bool cs_0xF005_online_count_t::has_olcnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF005_online_count_t::set_has_olcnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF005_online_count_t::clear_has_olcnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF005_online_count_t::clear_olcnt() {
  olcnt_ = 0u;
  clear_has_olcnt();
}
inline ::google::protobuf::uint32 cs_0xF005_online_count_t::olcnt() const {
  return olcnt_;
}
inline void cs_0xF005_online_count_t::set_olcnt(::google::protobuf::uint32 value) {
  set_has_olcnt();
  olcnt_ = value;
}

// optional .statlogger.zone_type_t zone = 3 [default = ALL];
inline bool cs_0xF005_online_count_t::has_zone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF005_online_count_t::set_has_zone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF005_online_count_t::clear_has_zone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF005_online_count_t::clear_zone() {
  zone_ = 3;
  clear_has_zone();
}
inline ::statlogger::zone_type_t cs_0xF005_online_count_t::zone() const {
  return static_cast< ::statlogger::zone_type_t >(zone_);
}
inline void cs_0xF005_online_count_t::set_zone(::statlogger::zone_type_t value) {
  assert(::statlogger::zone_type_t_IsValid(value));
  set_has_zone();
  zone_ = value;
}

// -------------------------------------------------------------------

// sc_0xF005_online_count_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF005_online_count_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF005_online_count_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF005_online_count_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF005_online_count_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF005_online_count_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF005_online_count_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF005_online_count_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF005_online_count_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF006_level_up_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF006_level_up_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF006_level_up_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF006_level_up_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF006_level_up_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF006_level_up_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF006_level_up_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF006_level_up_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF006_level_up_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF006_level_up_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF006_level_up_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF006_level_up_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF006_level_up_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF006_level_up_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF006_level_up_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF006_level_up_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF006_level_up_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// required uint32 level = 3;
inline bool cs_0xF006_level_up_t::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF006_level_up_t::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF006_level_up_t::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF006_level_up_t::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 cs_0xF006_level_up_t::level() const {
  return level_;
}
inline void cs_0xF006_level_up_t::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional string race = 4;
inline bool cs_0xF006_level_up_t::has_race() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cs_0xF006_level_up_t::set_has_race() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cs_0xF006_level_up_t::clear_has_race() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cs_0xF006_level_up_t::clear_race() {
  if (race_ != &::google::protobuf::internal::kEmptyString) {
    race_->clear();
  }
  clear_has_race();
}
inline const ::std::string& cs_0xF006_level_up_t::race() const {
  return *race_;
}
inline void cs_0xF006_level_up_t::set_race(const ::std::string& value) {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  race_->assign(value);
}
inline void cs_0xF006_level_up_t::set_race(const char* value) {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  race_->assign(value);
}
inline void cs_0xF006_level_up_t::set_race(const char* value, size_t size) {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  race_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF006_level_up_t::mutable_race() {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  return race_;
}
inline ::std::string* cs_0xF006_level_up_t::release_race() {
  clear_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = race_;
    race_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF006_level_up_t::set_allocated_race(::std::string* race) {
  if (race_ != &::google::protobuf::internal::kEmptyString) {
    delete race_;
  }
  if (race) {
    set_has_race();
    race_ = race;
  } else {
    clear_has_race();
    race_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// sc_0xF006_level_up_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF006_level_up_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF006_level_up_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF006_level_up_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF006_level_up_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF006_level_up_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF006_level_up_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF006_level_up_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF006_level_up_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF007_pay_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF007_pay_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF007_pay_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF007_pay_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF007_pay_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF007_pay_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF007_pay_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF007_pay_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF007_pay_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF007_pay_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF007_pay_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF007_pay_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF007_pay_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF007_pay_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF007_pay_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF007_pay_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF007_pay_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// optional bool isvip = 3;
inline bool cs_0xF007_pay_t::has_isvip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF007_pay_t::set_has_isvip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF007_pay_t::clear_has_isvip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF007_pay_t::clear_isvip() {
  isvip_ = false;
  clear_has_isvip();
}
inline bool cs_0xF007_pay_t::isvip() const {
  return isvip_;
}
inline void cs_0xF007_pay_t::set_isvip(bool value) {
  set_has_isvip();
  isvip_ = value;
}

// required uint32 pay_amount = 4;
inline bool cs_0xF007_pay_t::has_pay_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cs_0xF007_pay_t::set_has_pay_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cs_0xF007_pay_t::clear_has_pay_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cs_0xF007_pay_t::clear_pay_amount() {
  pay_amount_ = 0u;
  clear_has_pay_amount();
}
inline ::google::protobuf::uint32 cs_0xF007_pay_t::pay_amount() const {
  return pay_amount_;
}
inline void cs_0xF007_pay_t::set_pay_amount(::google::protobuf::uint32 value) {
  set_has_pay_amount();
  pay_amount_ = value;
}

// required .statlogger.unit_t pay_unit = 5 [default = FEN];
inline bool cs_0xF007_pay_t::has_pay_unit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cs_0xF007_pay_t::set_has_pay_unit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cs_0xF007_pay_t::clear_has_pay_unit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cs_0xF007_pay_t::clear_pay_unit() {
  pay_unit_ = 3;
  clear_has_pay_unit();
}
inline ::statlogger::unit_t cs_0xF007_pay_t::pay_unit() const {
  return static_cast< ::statlogger::unit_t >(pay_unit_);
}
inline void cs_0xF007_pay_t::set_pay_unit(::statlogger::unit_t value) {
  assert(::statlogger::unit_t_IsValid(value));
  set_has_pay_unit();
  pay_unit_ = value;
}

// required .statlogger.currency_t currency_type = 6 [default = MIBI];
inline bool cs_0xF007_pay_t::has_currency_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void cs_0xF007_pay_t::set_has_currency_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void cs_0xF007_pay_t::clear_has_currency_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void cs_0xF007_pay_t::clear_currency_type() {
  currency_type_ = 1;
  clear_has_currency_type();
}
inline ::statlogger::currency_t cs_0xF007_pay_t::currency_type() const {
  return static_cast< ::statlogger::currency_t >(currency_type_);
}
inline void cs_0xF007_pay_t::set_currency_type(::statlogger::currency_t value) {
  assert(::statlogger::currency_t_IsValid(value));
  set_has_currency_type();
  currency_type_ = value;
}

// required .statlogger.pay_reason_t pay_reason = 7;
inline bool cs_0xF007_pay_t::has_pay_reason() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void cs_0xF007_pay_t::set_has_pay_reason() {
  _has_bits_[0] |= 0x00000040u;
}
inline void cs_0xF007_pay_t::clear_has_pay_reason() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void cs_0xF007_pay_t::clear_pay_reason() {
  pay_reason_ = 1;
  clear_has_pay_reason();
}
inline ::statlogger::pay_reason_t cs_0xF007_pay_t::pay_reason() const {
  return static_cast< ::statlogger::pay_reason_t >(pay_reason_);
}
inline void cs_0xF007_pay_t::set_pay_reason(::statlogger::pay_reason_t value) {
  assert(::statlogger::pay_reason_t_IsValid(value));
  set_has_pay_reason();
  pay_reason_ = value;
}

// required uint32 outcome = 8;
inline bool cs_0xF007_pay_t::has_outcome() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void cs_0xF007_pay_t::set_has_outcome() {
  _has_bits_[0] |= 0x00000080u;
}
inline void cs_0xF007_pay_t::clear_has_outcome() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void cs_0xF007_pay_t::clear_outcome() {
  outcome_ = 0u;
  clear_has_outcome();
}
inline ::google::protobuf::uint32 cs_0xF007_pay_t::outcome() const {
  return outcome_;
}
inline void cs_0xF007_pay_t::set_outcome(::google::protobuf::uint32 value) {
  set_has_outcome();
  outcome_ = value;
}

// optional uint32 outcnt = 9 [default = 1];
inline bool cs_0xF007_pay_t::has_outcnt() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void cs_0xF007_pay_t::set_has_outcnt() {
  _has_bits_[0] |= 0x00000100u;
}
inline void cs_0xF007_pay_t::clear_has_outcnt() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void cs_0xF007_pay_t::clear_outcnt() {
  outcnt_ = 1u;
  clear_has_outcnt();
}
inline ::google::protobuf::uint32 cs_0xF007_pay_t::outcnt() const {
  return outcnt_;
}
inline void cs_0xF007_pay_t::set_outcnt(::google::protobuf::uint32 value) {
  set_has_outcnt();
  outcnt_ = value;
}

// required uint32 pay_channel = 10;
inline bool cs_0xF007_pay_t::has_pay_channel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void cs_0xF007_pay_t::set_has_pay_channel() {
  _has_bits_[0] |= 0x00000200u;
}
inline void cs_0xF007_pay_t::clear_has_pay_channel() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void cs_0xF007_pay_t::clear_pay_channel() {
  pay_channel_ = 0u;
  clear_has_pay_channel();
}
inline ::google::protobuf::uint32 cs_0xF007_pay_t::pay_channel() const {
  return pay_channel_;
}
inline void cs_0xF007_pay_t::set_pay_channel(::google::protobuf::uint32 value) {
  set_has_pay_channel();
  pay_channel_ = value;
}

// -------------------------------------------------------------------

// sc_0xF007_pay_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF007_pay_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF007_pay_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF007_pay_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF007_pay_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF007_pay_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF007_pay_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF007_pay_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF007_pay_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF008_free_golds_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF008_free_golds_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF008_free_golds_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF008_free_golds_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF008_free_golds_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF008_free_golds_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF008_free_golds_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF008_free_golds_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF008_free_golds_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF008_free_golds_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF008_free_golds_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF008_free_golds_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF008_free_golds_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF008_free_golds_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF008_free_golds_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF008_free_golds_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF008_free_golds_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// required uint32 amt = 3;
inline bool cs_0xF008_free_golds_t::has_amt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF008_free_golds_t::set_has_amt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF008_free_golds_t::clear_has_amt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF008_free_golds_t::clear_amt() {
  amt_ = 0u;
  clear_has_amt();
}
inline ::google::protobuf::uint32 cs_0xF008_free_golds_t::amt() const {
  return amt_;
}
inline void cs_0xF008_free_golds_t::set_amt(::google::protobuf::uint32 value) {
  set_has_amt();
  amt_ = value;
}

// -------------------------------------------------------------------

// sc_0xF008_free_golds_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF008_free_golds_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF008_free_golds_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF008_free_golds_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF008_free_golds_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF008_free_golds_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF008_free_golds_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF008_free_golds_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF008_free_golds_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF009_buy_item_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF009_buy_item_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF009_buy_item_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF009_buy_item_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF009_buy_item_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF009_buy_item_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF009_buy_item_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF009_buy_item_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF009_buy_item_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF009_buy_item_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF009_buy_item_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF009_buy_item_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF009_buy_item_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF009_buy_item_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF009_buy_item_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF009_buy_item_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF009_buy_item_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// optional bool isvip = 3;
inline bool cs_0xF009_buy_item_t::has_isvip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF009_buy_item_t::set_has_isvip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF009_buy_item_t::clear_has_isvip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF009_buy_item_t::clear_isvip() {
  isvip_ = false;
  clear_has_isvip();
}
inline bool cs_0xF009_buy_item_t::isvip() const {
  return isvip_;
}
inline void cs_0xF009_buy_item_t::set_isvip(bool value) {
  set_has_isvip();
  isvip_ = value;
}

// optional uint32 lv = 4;
inline bool cs_0xF009_buy_item_t::has_lv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cs_0xF009_buy_item_t::set_has_lv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cs_0xF009_buy_item_t::clear_has_lv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cs_0xF009_buy_item_t::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 cs_0xF009_buy_item_t::lv() const {
  return lv_;
}
inline void cs_0xF009_buy_item_t::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// required uint32 pay_amt = 5;
inline bool cs_0xF009_buy_item_t::has_pay_amt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cs_0xF009_buy_item_t::set_has_pay_amt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cs_0xF009_buy_item_t::clear_has_pay_amt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cs_0xF009_buy_item_t::clear_pay_amt() {
  pay_amt_ = 0u;
  clear_has_pay_amt();
}
inline ::google::protobuf::uint32 cs_0xF009_buy_item_t::pay_amt() const {
  return pay_amt_;
}
inline void cs_0xF009_buy_item_t::set_pay_amt(::google::protobuf::uint32 value) {
  set_has_pay_amt();
  pay_amt_ = value;
}

// required string outcome = 6;
inline bool cs_0xF009_buy_item_t::has_outcome() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void cs_0xF009_buy_item_t::set_has_outcome() {
  _has_bits_[0] |= 0x00000020u;
}
inline void cs_0xF009_buy_item_t::clear_has_outcome() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void cs_0xF009_buy_item_t::clear_outcome() {
  if (outcome_ != &::google::protobuf::internal::kEmptyString) {
    outcome_->clear();
  }
  clear_has_outcome();
}
inline const ::std::string& cs_0xF009_buy_item_t::outcome() const {
  return *outcome_;
}
inline void cs_0xF009_buy_item_t::set_outcome(const ::std::string& value) {
  set_has_outcome();
  if (outcome_ == &::google::protobuf::internal::kEmptyString) {
    outcome_ = new ::std::string;
  }
  outcome_->assign(value);
}
inline void cs_0xF009_buy_item_t::set_outcome(const char* value) {
  set_has_outcome();
  if (outcome_ == &::google::protobuf::internal::kEmptyString) {
    outcome_ = new ::std::string;
  }
  outcome_->assign(value);
}
inline void cs_0xF009_buy_item_t::set_outcome(const char* value, size_t size) {
  set_has_outcome();
  if (outcome_ == &::google::protobuf::internal::kEmptyString) {
    outcome_ = new ::std::string;
  }
  outcome_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF009_buy_item_t::mutable_outcome() {
  set_has_outcome();
  if (outcome_ == &::google::protobuf::internal::kEmptyString) {
    outcome_ = new ::std::string;
  }
  return outcome_;
}
inline ::std::string* cs_0xF009_buy_item_t::release_outcome() {
  clear_has_outcome();
  if (outcome_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = outcome_;
    outcome_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF009_buy_item_t::set_allocated_outcome(::std::string* outcome) {
  if (outcome_ != &::google::protobuf::internal::kEmptyString) {
    delete outcome_;
  }
  if (outcome) {
    set_has_outcome();
    outcome_ = outcome;
  } else {
    clear_has_outcome();
    outcome_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 outcnt = 7 [default = 1];
inline bool cs_0xF009_buy_item_t::has_outcnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void cs_0xF009_buy_item_t::set_has_outcnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void cs_0xF009_buy_item_t::clear_has_outcnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void cs_0xF009_buy_item_t::clear_outcnt() {
  outcnt_ = 1u;
  clear_has_outcnt();
}
inline ::google::protobuf::uint32 cs_0xF009_buy_item_t::outcnt() const {
  return outcnt_;
}
inline void cs_0xF009_buy_item_t::set_outcnt(::google::protobuf::uint32 value) {
  set_has_outcnt();
  outcnt_ = value;
}

// -------------------------------------------------------------------

// sc_0xF009_buy_item_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF009_buy_item_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF009_buy_item_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF009_buy_item_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF009_buy_item_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF009_buy_item_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF009_buy_item_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF009_buy_item_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF009_buy_item_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF00A_buy_other_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF00A_buy_other_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF00A_buy_other_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF00A_buy_other_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF00A_buy_other_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF00A_buy_other_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF00A_buy_other_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF00A_buy_other_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF00A_buy_other_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF00A_buy_other_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF00A_buy_other_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF00A_buy_other_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF00A_buy_other_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF00A_buy_other_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF00A_buy_other_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF00A_buy_other_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF00A_buy_other_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// optional bool isvip = 3;
inline bool cs_0xF00A_buy_other_t::has_isvip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF00A_buy_other_t::set_has_isvip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF00A_buy_other_t::clear_has_isvip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF00A_buy_other_t::clear_isvip() {
  isvip_ = false;
  clear_has_isvip();
}
inline bool cs_0xF00A_buy_other_t::isvip() const {
  return isvip_;
}
inline void cs_0xF00A_buy_other_t::set_isvip(bool value) {
  set_has_isvip();
  isvip_ = value;
}

// optional uint32 lv = 4;
inline bool cs_0xF00A_buy_other_t::has_lv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cs_0xF00A_buy_other_t::set_has_lv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cs_0xF00A_buy_other_t::clear_has_lv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cs_0xF00A_buy_other_t::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 cs_0xF00A_buy_other_t::lv() const {
  return lv_;
}
inline void cs_0xF00A_buy_other_t::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// required uint32 pay_amt = 5;
inline bool cs_0xF00A_buy_other_t::has_pay_amt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cs_0xF00A_buy_other_t::set_has_pay_amt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cs_0xF00A_buy_other_t::clear_has_pay_amt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cs_0xF00A_buy_other_t::clear_pay_amt() {
  pay_amt_ = 0u;
  clear_has_pay_amt();
}
inline ::google::protobuf::uint32 cs_0xF00A_buy_other_t::pay_amt() const {
  return pay_amt_;
}
inline void cs_0xF00A_buy_other_t::set_pay_amt(::google::protobuf::uint32 value) {
  set_has_pay_amt();
  pay_amt_ = value;
}

// required string reason = 6;
inline bool cs_0xF00A_buy_other_t::has_reason() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void cs_0xF00A_buy_other_t::set_has_reason() {
  _has_bits_[0] |= 0x00000020u;
}
inline void cs_0xF00A_buy_other_t::clear_has_reason() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void cs_0xF00A_buy_other_t::clear_reason() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& cs_0xF00A_buy_other_t::reason() const {
  return *reason_;
}
inline void cs_0xF00A_buy_other_t::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void cs_0xF00A_buy_other_t::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void cs_0xF00A_buy_other_t::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF00A_buy_other_t::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  return reason_;
}
inline ::std::string* cs_0xF00A_buy_other_t::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF00A_buy_other_t::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// sc_0xF00A_buy_other_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF00A_buy_other_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF00A_buy_other_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF00A_buy_other_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF00A_buy_other_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF00A_buy_other_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF00A_buy_other_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF00A_buy_other_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF00A_buy_other_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF00B_accept_task_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF00B_accept_task_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF00B_accept_task_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF00B_accept_task_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF00B_accept_task_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF00B_accept_task_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF00B_accept_task_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF00B_accept_task_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF00B_accept_task_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF00B_accept_task_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF00B_accept_task_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF00B_accept_task_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF00B_accept_task_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF00B_accept_task_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF00B_accept_task_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF00B_accept_task_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF00B_accept_task_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// optional uint32 lv = 3;
inline bool cs_0xF00B_accept_task_t::has_lv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF00B_accept_task_t::set_has_lv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF00B_accept_task_t::clear_has_lv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF00B_accept_task_t::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 cs_0xF00B_accept_task_t::lv() const {
  return lv_;
}
inline void cs_0xF00B_accept_task_t::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// required .statlogger.task_type_t type = 4;
inline bool cs_0xF00B_accept_task_t::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cs_0xF00B_accept_task_t::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cs_0xF00B_accept_task_t::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cs_0xF00B_accept_task_t::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::statlogger::task_type_t cs_0xF00B_accept_task_t::type() const {
  return static_cast< ::statlogger::task_type_t >(type_);
}
inline void cs_0xF00B_accept_task_t::set_type(::statlogger::task_type_t value) {
  assert(::statlogger::task_type_t_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string name = 5;
inline bool cs_0xF00B_accept_task_t::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cs_0xF00B_accept_task_t::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cs_0xF00B_accept_task_t::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cs_0xF00B_accept_task_t::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& cs_0xF00B_accept_task_t::name() const {
  return *name_;
}
inline void cs_0xF00B_accept_task_t::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void cs_0xF00B_accept_task_t::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void cs_0xF00B_accept_task_t::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF00B_accept_task_t::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* cs_0xF00B_accept_task_t::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF00B_accept_task_t::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// sc_0xF00B_accept_task_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF00B_accept_task_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF00B_accept_task_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF00B_accept_task_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF00B_accept_task_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF00B_accept_task_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF00B_accept_task_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF00B_accept_task_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF00B_accept_task_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF00C_finish_task_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF00C_finish_task_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF00C_finish_task_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF00C_finish_task_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF00C_finish_task_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF00C_finish_task_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF00C_finish_task_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF00C_finish_task_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF00C_finish_task_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF00C_finish_task_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF00C_finish_task_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF00C_finish_task_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF00C_finish_task_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF00C_finish_task_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF00C_finish_task_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF00C_finish_task_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF00C_finish_task_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// optional uint32 lv = 3;
inline bool cs_0xF00C_finish_task_t::has_lv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF00C_finish_task_t::set_has_lv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF00C_finish_task_t::clear_has_lv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF00C_finish_task_t::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 cs_0xF00C_finish_task_t::lv() const {
  return lv_;
}
inline void cs_0xF00C_finish_task_t::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// required .statlogger.task_type_t type = 4;
inline bool cs_0xF00C_finish_task_t::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cs_0xF00C_finish_task_t::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cs_0xF00C_finish_task_t::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cs_0xF00C_finish_task_t::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::statlogger::task_type_t cs_0xF00C_finish_task_t::type() const {
  return static_cast< ::statlogger::task_type_t >(type_);
}
inline void cs_0xF00C_finish_task_t::set_type(::statlogger::task_type_t value) {
  assert(::statlogger::task_type_t_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string name = 5;
inline bool cs_0xF00C_finish_task_t::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cs_0xF00C_finish_task_t::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cs_0xF00C_finish_task_t::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cs_0xF00C_finish_task_t::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& cs_0xF00C_finish_task_t::name() const {
  return *name_;
}
inline void cs_0xF00C_finish_task_t::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void cs_0xF00C_finish_task_t::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void cs_0xF00C_finish_task_t::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF00C_finish_task_t::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* cs_0xF00C_finish_task_t::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF00C_finish_task_t::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// sc_0xF00C_finish_task_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF00C_finish_task_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF00C_finish_task_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF00C_finish_task_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF00C_finish_task_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF00C_finish_task_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF00C_finish_task_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF00C_finish_task_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF00C_finish_task_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF00D_abort_task_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF00D_abort_task_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF00D_abort_task_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF00D_abort_task_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF00D_abort_task_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF00D_abort_task_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF00D_abort_task_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF00D_abort_task_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF00D_abort_task_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF00D_abort_task_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF00D_abort_task_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF00D_abort_task_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF00D_abort_task_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF00D_abort_task_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF00D_abort_task_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF00D_abort_task_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF00D_abort_task_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// optional uint32 lv = 3;
inline bool cs_0xF00D_abort_task_t::has_lv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF00D_abort_task_t::set_has_lv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF00D_abort_task_t::clear_has_lv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF00D_abort_task_t::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 cs_0xF00D_abort_task_t::lv() const {
  return lv_;
}
inline void cs_0xF00D_abort_task_t::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// required .statlogger.task_type_t type = 4;
inline bool cs_0xF00D_abort_task_t::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cs_0xF00D_abort_task_t::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cs_0xF00D_abort_task_t::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cs_0xF00D_abort_task_t::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::statlogger::task_type_t cs_0xF00D_abort_task_t::type() const {
  return static_cast< ::statlogger::task_type_t >(type_);
}
inline void cs_0xF00D_abort_task_t::set_type(::statlogger::task_type_t value) {
  assert(::statlogger::task_type_t_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string name = 5;
inline bool cs_0xF00D_abort_task_t::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cs_0xF00D_abort_task_t::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cs_0xF00D_abort_task_t::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cs_0xF00D_abort_task_t::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& cs_0xF00D_abort_task_t::name() const {
  return *name_;
}
inline void cs_0xF00D_abort_task_t::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void cs_0xF00D_abort_task_t::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void cs_0xF00D_abort_task_t::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF00D_abort_task_t::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* cs_0xF00D_abort_task_t::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF00D_abort_task_t::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// sc_0xF00D_abort_task_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF00D_abort_task_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF00D_abort_task_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF00D_abort_task_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF00D_abort_task_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF00D_abort_task_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF00D_abort_task_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF00D_abort_task_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF00D_abort_task_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF00E_obtain_spirit_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF00E_obtain_spirit_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF00E_obtain_spirit_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF00E_obtain_spirit_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF00E_obtain_spirit_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF00E_obtain_spirit_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF00E_obtain_spirit_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF00E_obtain_spirit_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF00E_obtain_spirit_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF00E_obtain_spirit_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF00E_obtain_spirit_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF00E_obtain_spirit_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF00E_obtain_spirit_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF00E_obtain_spirit_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF00E_obtain_spirit_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF00E_obtain_spirit_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF00E_obtain_spirit_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// optional uint32 lv = 3;
inline bool cs_0xF00E_obtain_spirit_t::has_lv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF00E_obtain_spirit_t::set_has_lv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF00E_obtain_spirit_t::clear_has_lv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF00E_obtain_spirit_t::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 cs_0xF00E_obtain_spirit_t::lv() const {
  return lv_;
}
inline void cs_0xF00E_obtain_spirit_t::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// optional bool isvip = 4;
inline bool cs_0xF00E_obtain_spirit_t::has_isvip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cs_0xF00E_obtain_spirit_t::set_has_isvip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cs_0xF00E_obtain_spirit_t::clear_has_isvip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cs_0xF00E_obtain_spirit_t::clear_isvip() {
  isvip_ = false;
  clear_has_isvip();
}
inline bool cs_0xF00E_obtain_spirit_t::isvip() const {
  return isvip_;
}
inline void cs_0xF00E_obtain_spirit_t::set_isvip(bool value) {
  set_has_isvip();
  isvip_ = value;
}

// required string spirit = 5;
inline bool cs_0xF00E_obtain_spirit_t::has_spirit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cs_0xF00E_obtain_spirit_t::set_has_spirit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cs_0xF00E_obtain_spirit_t::clear_has_spirit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cs_0xF00E_obtain_spirit_t::clear_spirit() {
  if (spirit_ != &::google::protobuf::internal::kEmptyString) {
    spirit_->clear();
  }
  clear_has_spirit();
}
inline const ::std::string& cs_0xF00E_obtain_spirit_t::spirit() const {
  return *spirit_;
}
inline void cs_0xF00E_obtain_spirit_t::set_spirit(const ::std::string& value) {
  set_has_spirit();
  if (spirit_ == &::google::protobuf::internal::kEmptyString) {
    spirit_ = new ::std::string;
  }
  spirit_->assign(value);
}
inline void cs_0xF00E_obtain_spirit_t::set_spirit(const char* value) {
  set_has_spirit();
  if (spirit_ == &::google::protobuf::internal::kEmptyString) {
    spirit_ = new ::std::string;
  }
  spirit_->assign(value);
}
inline void cs_0xF00E_obtain_spirit_t::set_spirit(const char* value, size_t size) {
  set_has_spirit();
  if (spirit_ == &::google::protobuf::internal::kEmptyString) {
    spirit_ = new ::std::string;
  }
  spirit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF00E_obtain_spirit_t::mutable_spirit() {
  set_has_spirit();
  if (spirit_ == &::google::protobuf::internal::kEmptyString) {
    spirit_ = new ::std::string;
  }
  return spirit_;
}
inline ::std::string* cs_0xF00E_obtain_spirit_t::release_spirit() {
  clear_has_spirit();
  if (spirit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spirit_;
    spirit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF00E_obtain_spirit_t::set_allocated_spirit(::std::string* spirit) {
  if (spirit_ != &::google::protobuf::internal::kEmptyString) {
    delete spirit_;
  }
  if (spirit) {
    set_has_spirit();
    spirit_ = spirit;
  } else {
    clear_has_spirit();
    spirit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// sc_0xF00E_obtain_spirit_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF00E_obtain_spirit_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF00E_obtain_spirit_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF00E_obtain_spirit_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF00E_obtain_spirit_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF00E_obtain_spirit_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF00E_obtain_spirit_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF00E_obtain_spirit_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF00E_obtain_spirit_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF00F_lose_spirit_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF00F_lose_spirit_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF00F_lose_spirit_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF00F_lose_spirit_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF00F_lose_spirit_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF00F_lose_spirit_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF00F_lose_spirit_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF00F_lose_spirit_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF00F_lose_spirit_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF00F_lose_spirit_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF00F_lose_spirit_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF00F_lose_spirit_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF00F_lose_spirit_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF00F_lose_spirit_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF00F_lose_spirit_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF00F_lose_spirit_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF00F_lose_spirit_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// optional uint32 lv = 3;
inline bool cs_0xF00F_lose_spirit_t::has_lv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF00F_lose_spirit_t::set_has_lv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF00F_lose_spirit_t::clear_has_lv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF00F_lose_spirit_t::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 cs_0xF00F_lose_spirit_t::lv() const {
  return lv_;
}
inline void cs_0xF00F_lose_spirit_t::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// optional bool isvip = 4;
inline bool cs_0xF00F_lose_spirit_t::has_isvip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cs_0xF00F_lose_spirit_t::set_has_isvip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cs_0xF00F_lose_spirit_t::clear_has_isvip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cs_0xF00F_lose_spirit_t::clear_isvip() {
  isvip_ = false;
  clear_has_isvip();
}
inline bool cs_0xF00F_lose_spirit_t::isvip() const {
  return isvip_;
}
inline void cs_0xF00F_lose_spirit_t::set_isvip(bool value) {
  set_has_isvip();
  isvip_ = value;
}

// required string spirit = 5;
inline bool cs_0xF00F_lose_spirit_t::has_spirit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cs_0xF00F_lose_spirit_t::set_has_spirit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cs_0xF00F_lose_spirit_t::clear_has_spirit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cs_0xF00F_lose_spirit_t::clear_spirit() {
  if (spirit_ != &::google::protobuf::internal::kEmptyString) {
    spirit_->clear();
  }
  clear_has_spirit();
}
inline const ::std::string& cs_0xF00F_lose_spirit_t::spirit() const {
  return *spirit_;
}
inline void cs_0xF00F_lose_spirit_t::set_spirit(const ::std::string& value) {
  set_has_spirit();
  if (spirit_ == &::google::protobuf::internal::kEmptyString) {
    spirit_ = new ::std::string;
  }
  spirit_->assign(value);
}
inline void cs_0xF00F_lose_spirit_t::set_spirit(const char* value) {
  set_has_spirit();
  if (spirit_ == &::google::protobuf::internal::kEmptyString) {
    spirit_ = new ::std::string;
  }
  spirit_->assign(value);
}
inline void cs_0xF00F_lose_spirit_t::set_spirit(const char* value, size_t size) {
  set_has_spirit();
  if (spirit_ == &::google::protobuf::internal::kEmptyString) {
    spirit_ = new ::std::string;
  }
  spirit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF00F_lose_spirit_t::mutable_spirit() {
  set_has_spirit();
  if (spirit_ == &::google::protobuf::internal::kEmptyString) {
    spirit_ = new ::std::string;
  }
  return spirit_;
}
inline ::std::string* cs_0xF00F_lose_spirit_t::release_spirit() {
  clear_has_spirit();
  if (spirit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spirit_;
    spirit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF00F_lose_spirit_t::set_allocated_spirit(::std::string* spirit) {
  if (spirit_ != &::google::protobuf::internal::kEmptyString) {
    delete spirit_;
  }
  if (spirit) {
    set_has_spirit();
    spirit_ = spirit;
  } else {
    clear_has_spirit();
    spirit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// sc_0xF00F_lose_spirit_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF00F_lose_spirit_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF00F_lose_spirit_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF00F_lose_spirit_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF00F_lose_spirit_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF00F_lose_spirit_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF00F_lose_spirit_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF00F_lose_spirit_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF00F_lose_spirit_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF010_new_trans_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF010_new_trans_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF010_new_trans_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF010_new_trans_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF010_new_trans_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF010_new_trans_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF010_new_trans_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF010_new_trans_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF010_new_trans_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF010_new_trans_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF010_new_trans_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF010_new_trans_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF010_new_trans_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF010_new_trans_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF010_new_trans_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF010_new_trans_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF010_new_trans_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// required .statlogger.reg_trans_step_t step = 3;
inline bool cs_0xF010_new_trans_t::has_step() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF010_new_trans_t::set_has_step() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF010_new_trans_t::clear_has_step() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF010_new_trans_t::clear_step() {
  step_ = 1;
  clear_has_step();
}
inline ::statlogger::reg_trans_step_t cs_0xF010_new_trans_t::step() const {
  return static_cast< ::statlogger::reg_trans_step_t >(step_);
}
inline void cs_0xF010_new_trans_t::set_step(::statlogger::reg_trans_step_t value) {
  assert(::statlogger::reg_trans_step_t_IsValid(value));
  set_has_step();
  step_ = value;
}

// -------------------------------------------------------------------

// sc_0xF010_new_trans_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF010_new_trans_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF010_new_trans_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF010_new_trans_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF010_new_trans_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF010_new_trans_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF010_new_trans_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF010_new_trans_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF010_new_trans_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}

// -------------------------------------------------------------------

// cs_0xF100_custom_t

// required .statloggercommon.game_info_t game = 1;
inline bool cs_0xF100_custom_t::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_0xF100_custom_t::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_0xF100_custom_t::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_0xF100_custom_t::clear_game() {
  if (game_ != NULL) game_->::statloggercommon::game_info_t::Clear();
  clear_has_game();
}
inline const ::statloggercommon::game_info_t& cs_0xF100_custom_t::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::statloggercommon::game_info_t* cs_0xF100_custom_t::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::statloggercommon::game_info_t;
  return game_;
}
inline ::statloggercommon::game_info_t* cs_0xF100_custom_t::release_game() {
  clear_has_game();
  ::statloggercommon::game_info_t* temp = game_;
  game_ = NULL;
  return temp;
}
inline void cs_0xF100_custom_t::set_allocated_game(::statloggercommon::game_info_t* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// required .statloggercommon.user_id_t uid = 2;
inline bool cs_0xF100_custom_t::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_0xF100_custom_t::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_0xF100_custom_t::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_0xF100_custom_t::clear_uid() {
  if (uid_ != NULL) uid_->::statloggercommon::user_id_t::Clear();
  clear_has_uid();
}
inline const ::statloggercommon::user_id_t& cs_0xF100_custom_t::uid() const {
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF100_custom_t::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) uid_ = new ::statloggercommon::user_id_t;
  return uid_;
}
inline ::statloggercommon::user_id_t* cs_0xF100_custom_t::release_uid() {
  clear_has_uid();
  ::statloggercommon::user_id_t* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void cs_0xF100_custom_t::set_allocated_uid(::statloggercommon::user_id_t* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
}

// required string stid = 3;
inline bool cs_0xF100_custom_t::has_stid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cs_0xF100_custom_t::set_has_stid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cs_0xF100_custom_t::clear_has_stid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cs_0xF100_custom_t::clear_stid() {
  if (stid_ != &::google::protobuf::internal::kEmptyString) {
    stid_->clear();
  }
  clear_has_stid();
}
inline const ::std::string& cs_0xF100_custom_t::stid() const {
  return *stid_;
}
inline void cs_0xF100_custom_t::set_stid(const ::std::string& value) {
  set_has_stid();
  if (stid_ == &::google::protobuf::internal::kEmptyString) {
    stid_ = new ::std::string;
  }
  stid_->assign(value);
}
inline void cs_0xF100_custom_t::set_stid(const char* value) {
  set_has_stid();
  if (stid_ == &::google::protobuf::internal::kEmptyString) {
    stid_ = new ::std::string;
  }
  stid_->assign(value);
}
inline void cs_0xF100_custom_t::set_stid(const char* value, size_t size) {
  set_has_stid();
  if (stid_ == &::google::protobuf::internal::kEmptyString) {
    stid_ = new ::std::string;
  }
  stid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF100_custom_t::mutable_stid() {
  set_has_stid();
  if (stid_ == &::google::protobuf::internal::kEmptyString) {
    stid_ = new ::std::string;
  }
  return stid_;
}
inline ::std::string* cs_0xF100_custom_t::release_stid() {
  clear_has_stid();
  if (stid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stid_;
    stid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF100_custom_t::set_allocated_stid(::std::string* stid) {
  if (stid_ != &::google::protobuf::internal::kEmptyString) {
    delete stid_;
  }
  if (stid) {
    set_has_stid();
    stid_ = stid;
  } else {
    clear_has_stid();
    stid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string sstid = 4;
inline bool cs_0xF100_custom_t::has_sstid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cs_0xF100_custom_t::set_has_sstid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cs_0xF100_custom_t::clear_has_sstid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cs_0xF100_custom_t::clear_sstid() {
  if (sstid_ != &::google::protobuf::internal::kEmptyString) {
    sstid_->clear();
  }
  clear_has_sstid();
}
inline const ::std::string& cs_0xF100_custom_t::sstid() const {
  return *sstid_;
}
inline void cs_0xF100_custom_t::set_sstid(const ::std::string& value) {
  set_has_sstid();
  if (sstid_ == &::google::protobuf::internal::kEmptyString) {
    sstid_ = new ::std::string;
  }
  sstid_->assign(value);
}
inline void cs_0xF100_custom_t::set_sstid(const char* value) {
  set_has_sstid();
  if (sstid_ == &::google::protobuf::internal::kEmptyString) {
    sstid_ = new ::std::string;
  }
  sstid_->assign(value);
}
inline void cs_0xF100_custom_t::set_sstid(const char* value, size_t size) {
  set_has_sstid();
  if (sstid_ == &::google::protobuf::internal::kEmptyString) {
    sstid_ = new ::std::string;
  }
  sstid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF100_custom_t::mutable_sstid() {
  set_has_sstid();
  if (sstid_ == &::google::protobuf::internal::kEmptyString) {
    sstid_ = new ::std::string;
  }
  return sstid_;
}
inline ::std::string* cs_0xF100_custom_t::release_sstid() {
  clear_has_sstid();
  if (sstid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sstid_;
    sstid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF100_custom_t::set_allocated_sstid(::std::string* sstid) {
  if (sstid_ != &::google::protobuf::internal::kEmptyString) {
    delete sstid_;
  }
  if (sstid) {
    set_has_sstid();
    sstid_ = sstid;
  } else {
    clear_has_sstid();
    sstid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string item = 5;
inline bool cs_0xF100_custom_t::has_item() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cs_0xF100_custom_t::set_has_item() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cs_0xF100_custom_t::clear_has_item() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cs_0xF100_custom_t::clear_item() {
  if (item_ != &::google::protobuf::internal::kEmptyString) {
    item_->clear();
  }
  clear_has_item();
}
inline const ::std::string& cs_0xF100_custom_t::item() const {
  return *item_;
}
inline void cs_0xF100_custom_t::set_item(const ::std::string& value) {
  set_has_item();
  if (item_ == &::google::protobuf::internal::kEmptyString) {
    item_ = new ::std::string;
  }
  item_->assign(value);
}
inline void cs_0xF100_custom_t::set_item(const char* value) {
  set_has_item();
  if (item_ == &::google::protobuf::internal::kEmptyString) {
    item_ = new ::std::string;
  }
  item_->assign(value);
}
inline void cs_0xF100_custom_t::set_item(const char* value, size_t size) {
  set_has_item();
  if (item_ == &::google::protobuf::internal::kEmptyString) {
    item_ = new ::std::string;
  }
  item_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF100_custom_t::mutable_item() {
  set_has_item();
  if (item_ == &::google::protobuf::internal::kEmptyString) {
    item_ = new ::std::string;
  }
  return item_;
}
inline ::std::string* cs_0xF100_custom_t::release_item() {
  clear_has_item();
  if (item_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = item_;
    item_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_0xF100_custom_t::set_allocated_item(::std::string* item) {
  if (item_ != &::google::protobuf::internal::kEmptyString) {
    delete item_;
  }
  if (item) {
    set_has_item();
    item_ = item;
  } else {
    clear_has_item();
    item_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .statlogger.op_type_t op = 6;
inline bool cs_0xF100_custom_t::has_op() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void cs_0xF100_custom_t::set_has_op() {
  _has_bits_[0] |= 0x00000020u;
}
inline void cs_0xF100_custom_t::clear_has_op() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void cs_0xF100_custom_t::clear_op() {
  op_ = 1;
  clear_has_op();
}
inline ::statlogger::op_type_t cs_0xF100_custom_t::op() const {
  return static_cast< ::statlogger::op_type_t >(op_);
}
inline void cs_0xF100_custom_t::set_op(::statlogger::op_type_t value) {
  assert(::statlogger::op_type_t_IsValid(value));
  set_has_op();
  op_ = value;
}

// optional string key = 7 [default = "key"];
inline bool cs_0xF100_custom_t::has_key() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void cs_0xF100_custom_t::set_has_key() {
  _has_bits_[0] |= 0x00000040u;
}
inline void cs_0xF100_custom_t::clear_has_key() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void cs_0xF100_custom_t::clear_key() {
  if (key_ != _default_key_) {
    key_->assign(*_default_key_);
  }
  clear_has_key();
}
inline const ::std::string& cs_0xF100_custom_t::key() const {
  return *key_;
}
inline void cs_0xF100_custom_t::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == _default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void cs_0xF100_custom_t::set_key(const char* value) {
  set_has_key();
  if (key_ == _default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void cs_0xF100_custom_t::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == _default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_0xF100_custom_t::mutable_key() {
  set_has_key();
  if (key_ == _default_key_) {
    key_ = new ::std::string(*_default_key_);
  }
  return key_;
}
inline ::std::string* cs_0xF100_custom_t::release_key() {
  clear_has_key();
  if (key_ == _default_key_) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(_default_key_);
    return temp;
  }
}
inline void cs_0xF100_custom_t::set_allocated_key(::std::string* key) {
  if (key_ != _default_key_) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(_default_key_);
  }
}

// optional double value = 8;
inline bool cs_0xF100_custom_t::has_value() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void cs_0xF100_custom_t::set_has_value() {
  _has_bits_[0] |= 0x00000080u;
}
inline void cs_0xF100_custom_t::clear_has_value() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void cs_0xF100_custom_t::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double cs_0xF100_custom_t::value() const {
  return value_;
}
inline void cs_0xF100_custom_t::set_value(double value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// sc_0xF100_custom_t

// required .statloggercommon.return_t ret = 1;
inline bool sc_0xF100_custom_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_0xF100_custom_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_0xF100_custom_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_0xF100_custom_t::clear_ret() {
  if (ret_ != NULL) ret_->::statloggercommon::return_t::Clear();
  clear_has_ret();
}
inline const ::statloggercommon::return_t& sc_0xF100_custom_t::ret() const {
  return ret_ != NULL ? *ret_ : *default_instance_->ret_;
}
inline ::statloggercommon::return_t* sc_0xF100_custom_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) ret_ = new ::statloggercommon::return_t;
  return ret_;
}
inline ::statloggercommon::return_t* sc_0xF100_custom_t::release_ret() {
  clear_has_ret();
  ::statloggercommon::return_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void sc_0xF100_custom_t::set_allocated_ret(::statloggercommon::return_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace statlogger

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::statlogger::zone_type_t>() {
  return ::statlogger::zone_type_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::statlogger::unit_t>() {
  return ::statlogger::unit_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::statlogger::currency_t>() {
  return ::statlogger::currency_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::statlogger::pay_reason_t>() {
  return ::statlogger::pay_reason_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::statlogger::task_type_t>() {
  return ::statlogger::task_type_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::statlogger::reg_trans_step_t>() {
  return ::statlogger::reg_trans_step_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::statlogger::op_type_t>() {
  return ::statlogger::op_type_t_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_statlogger_2eproto__INCLUDED
